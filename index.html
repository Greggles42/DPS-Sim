<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EverQuest DPS Simulator</title>
  <style>
    :root {
      --bg: #1a1d23;
      --panel: #252830;
      --border: #3d4452;
      --text: #e6e8ec;
      --muted: #8b909a;
      --accent: #7eb8da;
      --input-bg: #1e2128;
      --section-gap: 1rem;
    }
    * { box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      margin: 0;
      padding: 1.5rem;
      line-height: 1.5;
    }
    h1 {
      font-size: 1.5rem;
      font-weight: 600;
      margin: 0 0 1rem;
      color: var(--accent);
    }
    .grid {
      display: grid;
      gap: var(--section-gap);
      max-width: 900px;
    }
    @media (min-width: 700px) {
      .grid { grid-template-columns: 1fr 1fr; }
    }
    .grid-full-width { grid-column: 1 / -1; }
    section {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem 1.25rem;
    }
    section h2 {
      font-size: 0.9rem;
      font-weight: 600;
      margin: 0 0 0.75rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .weapon-section-header { margin-bottom: 0.25rem; }
    .weapon-section-header h2 { margin: 0; }
    .weapon-icon-wrap {
      position: absolute;
      top: 1rem;
      right: 1.25rem;
      width: 56px;
      height: 56px;
      cursor: pointer;
    }
    .weapon-icon-wrap .weapon-icon {
      width: 56px;
      height: 56px;
      object-fit: contain;
    }
    .section--core.weapon-section { position: relative; }
    .weapon-name {
      display: block;
      font-size: 1.15rem;
      font-weight: 600;
      color: var(--text);
      text-transform: none;
      letter-spacing: 0;
      margin: -0.35rem 0 0.15rem 0;
      min-height: 1.4em;
    }
    .weapon-skill {
      display: block;
      font-size: 0.8rem;
      font-weight: 400;
      color: var(--muted);
      margin: 0 0 0.6rem 0;
    }
    .collapse-summary {
      font-size: 0.8rem;
      color: var(--muted);
      cursor: pointer;
      padding: 0.35rem 0;
      margin-bottom: 0.5rem;
      user-select: none;
      list-style: none;
    }
    .collapse-summary::-webkit-details-marker { display: none; }
    .collapse-summary::before { content: '▸ '; }
    details[open] .collapse-summary::before { content: '▾ '; }
    details.collapse-secondary { margin-bottom: 0.75rem; }
    details.collapse-secondary summary { margin-bottom: 0; }
    details.collapse-secondary .hint { margin-bottom: 0.5rem; }
    label {
      display: block;
      font-size: 0.85rem;
      margin-bottom: 0.25rem;
      color: var(--muted);
    }
    input, select {
      width: 100%;
      padding: 0.5rem 0.6rem;
      background: var(--input-bg);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      font-size: 0.95rem;
      margin-bottom: 0.75rem;
    }
    input:focus, select:focus {
      outline: none;
      border-color: var(--accent);
    }
    .row {
      display: flex;
      gap: 0.75rem;
      margin-bottom: 0.75rem;
    }
    .row > * { flex: 1; }
    .row input, .row select { margin-bottom: 0; }

    /* Character & Haste: compact layout */
    .char-haste-section label { font-size: 0.75rem; margin-bottom: 0.15rem; }
    .char-haste-section input, .char-haste-section select {
      padding: 0.25rem 0.35rem;
      font-size: 0.9rem;
      margin-bottom: 0;
    }
    .char-primary-row { margin-bottom: 0.5rem; }
    .char-primary-row, .char-secondary-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem 1rem;
      align-items: flex-end;
    }
    .char-secondary-row { margin-bottom: 0.4rem; }
    .char-field { flex: 0 0 auto; }
    .char-field-num input { width: 4rem; max-width: 4rem; }
    .char-field select { min-width: 7rem; }
    .char-hint { margin: 0.25rem 0 0.4rem; font-size: 0.72rem; }
    .char-hint-below-primary { margin-top: 0.5rem; }
    .char-details { margin-top: 0.25rem; }
    .char-details .char-secondary-row { margin-bottom: 0.35rem; }
    .char-skill-row { display: flex; flex-wrap: wrap; gap: 0.5rem 1rem; margin-bottom: 0.35rem; }
    .char-checkbox-row { display: flex; flex-wrap: wrap; gap: 0.5rem 1rem; margin-bottom: 0.35rem; }
    .char-checkbox { margin: 0.15rem 0.5rem 0.15rem 0; font-size: 0.8rem; }
    button {
      background: var(--accent);
      color: var(--bg);
      border: none;
      padding: 0.6rem 1.2rem;
      border-radius: 4px;
      font-weight: 600;
      font-size: 0.95rem;
      cursor: pointer;
      margin-top: 0.5rem;
    }
    button:hover { filter: brightness(1.1); }
    button:active { filter: brightness(0.95); }
    #btn-run, #btn-run-ranged {
      display: block;
      width: 100%;
      margin: 1rem 0 0;
      padding: 0.9rem 1.75rem;
      font-size: 1.1rem;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.25);
      transition: transform 0.1s ease, box-shadow 0.15s ease;
    }
    #btn-run:hover, #btn-run-ranged:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(126, 184, 218, 0.35);
    }
    #btn-run:active, #btn-run-ranged:active { transform: translateY(0); }
    #report {
      white-space: pre-wrap;
      font-family: ui-monospace, 'Cascadia Code', monospace;
      font-size: 0.85rem;
      background: var(--input-bg);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 1rem;
      margin-top: 1rem;
      min-height: 120px;
    }
    .hint { font-size: 0.75rem; color: var(--muted); margin-top: -0.5rem; margin-bottom: 0.75rem; }
    .small-label { display: block; font-size: 0.75rem; color: var(--muted); margin-bottom: 0.2rem; }
    .info-icon { display: inline-flex; align-items: center; justify-content: center; width: 1em; height: 1em; margin-left: 0.25rem; font-size: 0.85em; color: var(--accent); cursor: help; border: 1px solid var(--border); border-radius: 50%; }
    .radio-group { display: flex; gap: 1rem; align-items: center; margin-bottom: 0.75rem; flex-wrap: wrap; }
    .radio-group label { display: flex; align-items: center; gap: 0.35rem; margin-bottom: 0; cursor: pointer; }
    .radio-group input[type="radio"] { width: auto; margin: 0; }
    .radio-option-main { font-size: 1.05rem; font-weight: 600; color: var(--text); }
    .radio-option-note { font-size: 0.85rem; color: var(--muted); font-weight: 400; }
    .checkbox-label { display: flex; align-items: center; gap: 0.35rem; cursor: pointer; margin-bottom: 0.25rem; }
    .checkbox-label input[type="checkbox"] { width: auto; margin: 0; }
    .main-layout {
      display: block;
      margin-top: var(--section-gap);
    }
    @media (min-width: 1150px) {
      .main-layout {
        display: flex;
        flex-direction: row;
        align-items: flex-start;
        gap: var(--section-gap);
        margin-top: var(--section-gap);
      }
      .main-layout .main-left {
        flex: 1 1 auto;
        min-width: 0;
        max-width: 920px;
      }
      .main-layout .histogram-aside {
        flex: 1 1 auto;
        min-width: 300px;
        margin-top: 0;
        position: sticky;
        top: 1.5rem;
        max-height: calc(100vh - 3rem);
        overflow-y: auto;
      }
    }
    .main-left {
      display: flex;
      flex-direction: column;
      gap: var(--section-gap);
    }
    .histogram-aside {
      display: flex;
      flex-direction: column;
      gap: var(--section-gap);
      margin-top: var(--section-gap);
    }
    .report-section,
    .histogram-panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem 1.25rem;
    }
    .report-section { max-width: 900px; }
    .report-section h2,
    .histogram-panel h2 {
      font-size: 0.9rem;
      font-weight: 600;
      margin: 0 0 0.75rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    #histogram-container { max-width: 100%; margin-top: 0; }
    .histogram-section { margin-bottom: 1.5rem; }
    .histogram-section h3 { font-size: 0.9rem; color: var(--muted); margin: 0 0 0.5rem; }
    .histogram-chart { display: flex; align-items: flex-end; gap: 2px; height: 120px; min-height: 120px; padding: 0.5rem 0; }
    .histogram-bar { background: var(--accent); border-radius: 2px 2px 0 0; min-width: 4px; min-height: 2px; }
    .histogram-bar:hover { filter: brightness(1.2); }
    .histogram-legend { font-size: 0.75rem; color: var(--muted); margin-top: 0.25rem; }
    .tab-bar { display: flex; gap: 0; margin-bottom: 0; border-bottom: 1px solid var(--border); }
    .tab-btn {
      padding: 0.6rem 1.25rem;
      background: transparent;
      color: var(--muted);
      border: none;
      border-bottom: 2px solid transparent;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      margin: 0;
      border-radius: 0;
    }
    .tab-btn:hover { color: var(--text); }
    .tab-btn.active { color: var(--accent); border-bottom-color: var(--accent); }
    .tab-panel { display: block; }
    .tab-panel.hidden { display: none; }
    .tab-content-wrapper { max-width: 900px; }
    .banner {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 1.5rem;
      flex-wrap: wrap;
      margin-bottom: 0.5rem;
    }
    .banner-left { flex: 1; min-width: 0; }
    #dps-display {
      flex-shrink: 0;
      text-align: right;
      font-weight: 700;
      color: var(--accent);
      line-height: 1.2;
    }
    #dps-display .dps-label { font-size: 0.75rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: var(--muted); margin-bottom: 0.2rem; }
    #dps-value { font-size: 3.25rem; display: block; }
    #sim-history-list { max-height: 320px; overflow-y: auto; font-size: 0.85rem; }
    .sim-history-row { display: grid; grid-template-columns: 1fr 1fr auto auto auto; gap: 0.5rem 0.75rem; align-items: center; padding: 0.5rem 0; border-bottom: 1px solid var(--border); }
    .sim-history-row:last-child { border-bottom: none; }
    .sim-history-header { font-size: 0.7rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.04em; color: var(--muted); padding-bottom: 0.35rem; border-bottom: 1px solid var(--border); margin-bottom: 0.25rem; }
    .sim-history-row .sim-history-w1, .sim-history-row .sim-history-w2 { min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .sim-history-row .sim-history-atk, .sim-history-row .sim-history-ac, .sim-history-row .sim-history-dps { text-align: right; white-space: nowrap; }
    .sim-history-row .sim-history-dps { font-weight: 600; color: var(--accent); }
    .sim-history-clear-btn { margin-top: 0.5rem; padding: 0.4rem 0.75rem; font-size: 0.85rem; background: var(--input-bg); color: var(--muted); border: 1px solid var(--border); border-radius: 4px; cursor: pointer; }
    .sim-history-clear-btn:hover { color: var(--text); border-color: var(--accent); }

    /* Item search autofilter */
    .item-search-wrap { position: relative; margin-bottom: 0.75rem; }
    .item-search-wrap input { margin-bottom: 0; }
    .item-search-list {
      position: absolute;
      left: 0;
      right: 0;
      top: 100%;
      margin-top: 2px;
      max-height: 280px;
      overflow-y: auto;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 4px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      z-index: 100;
      display: none;
    }
    .item-search-list.is-open { display: block; }
    .item-search-list .item-search-section { padding: 0.35rem 0.5rem 0.2rem; font-size: 0.7rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: var(--muted); border-bottom: 1px solid var(--border); }
    .item-search-list .item-search-section:first-child { padding-top: 0.5rem; }
    .item-search-item {
      padding: 0.5rem 0.6rem;
      cursor: pointer;
      font-size: 0.9rem;
      border: none;
      background: none;
      width: 100%;
      text-align: left;
      color: var(--text);
    }
    .item-search-item:hover { background: var(--input-bg); }
    .item-search-item .item-search-item-detail { font-size: 0.75rem; color: var(--muted); margin-top: 0.15rem; }
    .item-search-list .item-search-msg { padding: 0.6rem 0.6rem; font-size: 0.85rem; color: var(--muted); }

    /* Offhand disabled when main hand is 2H */
    #weapon2-section.is-disabled {
      opacity: 0.55;
      pointer-events: none;
      background: rgba(0, 0, 0, 0.2);
    }
    #weapon2-section.is-disabled .weapon-section-header h2,
    #weapon2-section.is-disabled .weapon-name {
      text-decoration: line-through;
    }
  </style>
</head>
<body>
  <div class="banner">
    <div class="banner-left">
      <h1>EverQuest DPS Simulator <span id="app-version" style="font-weight: 400; color: var(--muted); font-size: 0.85rem;">v0.8</span></h1>
      <p class="muted" style="margin:0 0 1rem; color: var(--muted); font-size: 0.9rem;">
        Formulas based on <a href="https://github.com/SecretsOTheP/EQMacEmu/blob/main/zone/attack.cpp" target="_blank" rel="noopener" style="color: var(--accent);">EQMacEmu attack.cpp</a>.
      </p>
    </div>
    <div id="dps-display" title="Total DPS from last run">
      <div class="dps-label">Total DPS</div>
      <span id="dps-value">—</span>
    </div>
  </div>

  <div class="tab-bar">
    <button type="button" class="tab-btn active" id="tab-melee" aria-selected="true">Melee</button>
    <button type="button" class="tab-btn" id="tab-ranged" aria-selected="false">Ranged</button>
  </div>

  <div class="main-layout">
  <div class="main-left">
  <div class="tab-content-wrapper">
  <div id="melee-tab" class="tab-panel">
  <div class="grid">
    <section class="section--core grid-full-width char-haste-section" id="character-haste-section">
      <h2>Character & Haste</h2>
      <div class="char-primary-row">
        <div class="char-field"><label for="class">Class</label><select id="class">
          <option value="">None (manual)</option>
          <option value="warrior">Warrior</option>
          <option value="paladin">Paladin</option>
          <option value="ranger">Ranger</option>
          <option value="shadowknight">Shadowknight</option>
          <option value="monk" selected>Monk</option>
          <option value="rogue">Rogue</option>
          <option value="bard">Bard</option>
          <option value="beastlord">Beastlord</option>
        </select></div>
        <div class="char-field char-field-num"><label for="level">Level</label><input type="number" id="level" min="1" max="65" value="60" placeholder="60"></div>
        <div class="char-field char-field-num"><label for="haste">Haste % <span class="info-icon" title="Worn + Spell + v3 Haste">&#8505;</span></label><input type="number" id="haste" min="0" value="99" placeholder="99"></div>
        <div class="char-field char-field-num"><label for="worn-attack">Worn ATK</label><input type="number" id="worn-attack" min="0" value="0" placeholder="0"></div>
        <div class="char-field char-field-num"><label for="spell-attack">Spell ATK</label><input type="number" id="spell-attack" min="0" value="0" placeholder="0"></div>
      </div>
      <p class="hint char-hint char-hint-below-primary" id="class-hint">Class and level auto-fill skills and weapon caps. Edit below to override.</p>
      <details class="collapse-secondary char-details">
        <summary class="collapse-summary">Skills, stats, options</summary>
        <div class="char-secondary-row">
          <div class="char-field char-field-num"><label for="offense-skill" class="small-label">Offense</label><input type="number" id="offense-skill" min="0" max="255" value="252" placeholder="252" title="Used for to-hit."></div>
          <div class="char-field char-field-num"><label for="double-attack" class="small-label">Double ATK</label><input type="number" id="double-attack" min="0" value="250" placeholder="250"></div>
          <div class="char-field char-field-num"><label for="dual-wield" class="small-label">Dual wield</label><input type="number" id="dual-wield" min="0" value="252" placeholder="0"></div>
        </div>
        <div class="char-skill-row">
          <div class="char-field char-field-num"><label for="skill-1hb" class="small-label">1HB</label><input type="number" id="skill-1hb" min="0" max="255" placeholder="0" title="1-handed blunt"></div>
          <div class="char-field char-field-num"><label for="skill-1hs" class="small-label">1HS</label><input type="number" id="skill-1hs" min="0" max="255" placeholder="0" title="1-handed slash"></div>
          <div class="char-field char-field-num"><label for="skill-1hp" class="small-label">Piercing</label><input type="number" id="skill-1hp" min="0" max="255" placeholder="0" title="Piercing (1HP/2HP)"></div>
          <div class="char-field char-field-num"><label for="skill-2hb" class="small-label">2HB</label><input type="number" id="skill-2hb" min="0" max="255" placeholder="0" title="2-handed blunt"></div>
          <div class="char-field char-field-num"><label for="skill-2hs" class="small-label">2HS</label><input type="number" id="skill-2hs" min="0" max="255" placeholder="0" title="2-handed slash"></div>
          <div class="char-field char-field-num"><label for="skill-h2h" class="small-label">H2H</label><input type="number" id="skill-h2h" min="0" max="255" placeholder="0" title="Hand to hand"></div>
          <div class="char-field char-field-num"><label for="skill-archery" class="small-label">Archery</label><input type="number" id="skill-archery" min="0" max="255" placeholder="0" title="Archery"></div>
          <div class="char-field char-field-num"><label for="skill-throwing" class="small-label">Throwing</label><input type="number" id="skill-throwing" min="0" max="255" placeholder="0" title="Throwing"></div>
        </div>
        <div class="char-secondary-row">
          <div class="char-field char-field-num"><label for="str" class="small-label">STR</label><input type="number" id="str" min="1" value="255" placeholder="255"></div>
          <div class="char-field char-field-num"><label for="dex" class="small-label">DEX</label><input type="number" id="dex" min="1" value="255" placeholder="255"></div>
          <div class="char-field char-field-num"><label for="crit-chance-aa" class="small-label">Crit %</label><input type="number" id="crit-chance-aa" min="0" value="6" placeholder="0"></div>
        </div>
        <div class="char-checkbox-row">
          <label class="checkbox-label char-checkbox"><input type="checkbox" id="ambidexterity-aa"> Ambidexterity (+32 dual wield)</label>
          <label class="checkbox-label char-checkbox"><input type="checkbox" id="special-attacks"> Flying Kick / Backstab on cooldown</label>
        </div>
        <p class="hint char-hint" id="special-hint">Monk: Flying Kick every 8s. Rogue: Backstab every 12s.</p>
        <div id="rogue-backstab-mod-row" style="display: none;">
          <div class="char-secondary-row">
            <div class="char-field char-field-num"><label for="backstab-skill" class="small-label">Backstab skill</label><input type="number" id="backstab-skill" min="0" value="225" placeholder="225"></div>
            <div class="char-field char-field-num"><label for="backstab-mod" class="small-label">Backstab mod %</label><input type="number" id="backstab-mod" min="0" value="0" placeholder="0"></div>
          </div>
        </div>
        <div id="fistweaving-row" style="display: none;">
          <label class="checkbox-label char-checkbox"><input type="checkbox" id="fistweaving"> Fistweaving</label>
        </div>
      </details>
    </section>

    <section class="section--core weapon-section">
      <div class="weapon-icon-wrap" id="w1-weapon-icon-wrap" style="display:none"><img id="w1-weapon-icon" class="weapon-icon" src="" alt=""></div>
      <div class="weapon-section-header"><h2>Weapon 1 (Main Hand)</h2></div>
      <div id="w1-weapon-name" class="weapon-name" aria-live="polite"></div>
      <div id="w1-weapon-skill" class="weapon-skill"></div>
      <div class="item-search-wrap">
        <label for="w1-item-search">Search items (API)</label>
        <input type="text" id="w1-item-search" placeholder="Type 3+ characters to search..." autocomplete="off">
        <div id="w1-item-search-list" class="item-search-list" role="listbox"></div>
      </div>
      <input type="hidden" id="w1-is2h-override" value="0">
      <div class="row">
        <div><label for="w1-damage" class="small-label">Damage</label><input type="number" id="w1-damage" min="0" value="12" placeholder="0 = unequipped"></div>
        <div><label for="w1-delay" class="small-label">Delay (decisec)</label><input type="number" id="w1-delay" min="0" value="40" placeholder="0 = unequipped, 40 = 4.0s"></div>
      </div>
      <p class="hint">Delay in tenths of a second (40 = 4.0s, 25 = 2.5s).</p>
      <details class="collapse-secondary">
        <summary class="collapse-summary">Proc, elemental &amp; bane</summary>
        <label for="w1-proc">Proc spell (name or leave blank)</label>
        <input type="text" id="w1-proc" placeholder="e.g. Flaming Sword">
        <label for="w1-proc-damage">Proc spell damage (on proc)</label>
        <input type="number" id="w1-proc-damage" min="0" value="0" placeholder="0">
        <div class="row">
          <div><label for="w1-elem-type" class="small-label">Elemental type</label><select id="w1-elem-type">
            <option value="">None</option>
            <option value="fire">Fire</option>
            <option value="cold">Cold</option>
            <option value="poison">Poison</option>
            <option value="disease">Disease</option>
            <option value="magic">Magic</option>
          </select></div>
          <div><label for="w1-elem-damage" class="small-label">Elem dmg</label><input type="number" id="w1-elem-damage" min="0" value="0" placeholder="0"></div>
          <div><label for="w1-bane" class="small-label">Bane dmg</label><input type="number" id="w1-bane" min="0" value="0" placeholder="0"></div>
        </div>
      </details>
    </section>

    <section id="weapon2-section" class="section--core weapon-section">
      <div class="weapon-icon-wrap" id="w2-weapon-icon-wrap" style="display:none"><img id="w2-weapon-icon" class="weapon-icon" src="" alt=""></div>
      <div class="weapon-section-header"><h2>Weapon 2 (Offhand, optional)</h2></div>
      <div id="w2-weapon-name" class="weapon-name" aria-live="polite"></div>
      <div id="w2-weapon-skill" class="weapon-skill"></div>
      <div class="item-search-wrap">
        <label for="w2-item-search">Search items (API)</label>
        <input type="text" id="w2-item-search" placeholder="Type 3+ characters to search..." autocomplete="off">
        <div id="w2-item-search-list" class="item-search-list" role="listbox"></div>
      </div>
      <div class="row">
        <div><label for="w2-damage" class="small-label">Damage</label><input type="number" id="w2-damage" min="0" value="0" placeholder="0 = no offhand"></div>
        <div><label for="w2-delay" class="small-label">Delay (decisec)</label><input type="number" id="w2-delay" min="0" value="0" placeholder="0"></div>
      </div>
      <p class="hint">Delay in tenths of a second (40 = 4.0s, 25 = 2.5s)</p>
      <details class="collapse-secondary">
        <summary class="collapse-summary">Proc, elemental &amp; bane</summary>
        <label for="w2-proc">Proc spell (name or leave blank)</label>
        <input type="text" id="w2-proc" placeholder="e.g. Poison">
        <label for="w2-proc-damage">Proc spell damage (on proc)</label>
        <input type="number" id="w2-proc-damage" min="0" value="0" placeholder="0">
        <div class="row">
          <div><label for="w2-elem-type" class="small-label">Elemental type</label><select id="w2-elem-type">
            <option value="">None</option>
            <option value="fire">Fire</option>
            <option value="cold">Cold</option>
            <option value="poison">Poison</option>
            <option value="disease">Disease</option>
            <option value="magic">Magic</option>
          </select></div>
          <div><label for="w2-elem-damage" class="small-label">Elem dmg</label><input type="number" id="w2-elem-damage" min="0" value="0" placeholder="0"></div>
          <div><label for="w2-bane" class="small-label">Bane dmg</label><input type="number" id="w2-bane" min="0" value="0" placeholder="0"></div>
        </div>
      </details>
    </section>

    <section class="section--core">
      <h2>Target & Fight</h2>
      <label>Attacking from</label>
      <div class="radio-group">
        <label><input type="radio" name="from-behind" value="0"><span class="radio-option-main">Front</span> <span class="radio-option-note">(use avoidance)</span></label>
        <label><input type="radio" name="from-behind" value="1" checked><span class="radio-option-main">Behind</span> <span class="radio-option-note">(no dodge/parry/riposte/block)</span></label>
      </div>
      <p class="hint">Behind: misses still occur from to-hit vs avoidance; only block/parry/dodge/riposte are skipped.</p>
      <div class="row">
        <div><label for="target-ac" class="small-label">Target AC</label><input type="number" id="target-ac" min="1" value="550" placeholder="550" title="Mitigation for damage roll; does not affect hit chance."></div>
        <div><label for="mob-level" class="small-label">Mob level</label><input type="number" id="mob-level" min="1" max="70" value="60" placeholder="60" title="Used for mitigation and avoidance (hit chance)."></div>
      </div>
      <div class="row">
        <div><label for="duration" class="small-label">Fight duration (sec)</label><input type="number" id="duration" min="1" value="6000" placeholder="6000"></div>
        <div><label for="runs" class="small-label">Number of runs</label><input type="number" id="runs" min="1" value="20" placeholder="20"></div>
      </div>
      <details class="collapse-secondary">
        <summary class="collapse-summary">Resistances &amp; bane options</summary>
        <label>Target resistances (for elemental damage)</label>
        <div class="row">
          <div><label for="target-mr" class="small-label">MR</label><input type="number" id="target-mr" min="0" value="35" placeholder="35"></div>
          <div><label for="target-fr" class="small-label">FR</label><input type="number" id="target-fr" min="0" value="35" placeholder="35"></div>
          <div><label for="target-cr" class="small-label">CR</label><input type="number" id="target-cr" min="0" value="35" placeholder="35"></div>
          <div><label for="target-pr" class="small-label">PR</label><input type="number" id="target-pr" min="0" value="35" placeholder="35"></div>
          <div><label for="target-dr" class="small-label">DR</label><input type="number" id="target-dr" min="0" value="35" placeholder="35"></div>
        </div>
        <p class="hint">Magic, Fire, Cold, Poison, Disease. Used when weapons have elemental damage.</p>
        <label class="checkbox-label"><input type="checkbox" id="apply-bane"> Apply Bane Damage</label>
        <p class="hint">When checked, each weapon's bane damage is added to its base damage.</p>
      </details>
      <button type="button" id="btn-run">Run simulation</button>
    </section>
  </div>
  </div>

  <div id="ranged-tab" class="tab-panel hidden">
  <div class="grid">
    <section class="section--core">
      <h2>Ranged weapon</h2>
      <div class="item-search-wrap">
        <label for="ranged-weapon-item-search">Search items (API)</label>
        <input type="text" id="ranged-weapon-item-search" placeholder="Type 3+ characters to search..." autocomplete="off">
        <div id="ranged-weapon-item-search-list" class="item-search-list" role="listbox"></div>
      </div>
      <div class="row">
        <div><label for="ranged-damage" class="small-label">Damage</label><input type="number" id="ranged-damage" min="1" value="12" placeholder="e.g. 12"></div>
        <div><label for="ranged-delay" class="small-label">Delay (decisec)</label><input type="number" id="ranged-delay" min="10" value="40" placeholder="40 = 4.0s"></div>
      </div>
      <p class="hint">Delay in tenths of a second (40 = 4.0s, 25 = 2.5s)</p>
      <details class="collapse-secondary">
        <summary class="collapse-summary">Proc, elemental &amp; bane</summary>
        <label for="ranged-proc">Proc spell (name or leave blank)</label>
        <input type="text" id="ranged-proc" placeholder="e.g. Flaming Arrows">
        <label for="ranged-proc-damage">Proc spell damage (on proc)</label>
        <input type="number" id="ranged-proc-damage" min="0" value="0" placeholder="0">
        <div class="row">
          <div><label for="ranged-elem-type" class="small-label">Elemental type</label><select id="ranged-elem-type">
            <option value="">None</option>
            <option value="fire">Fire</option>
            <option value="cold">Cold</option>
            <option value="poison">Poison</option>
            <option value="disease">Disease</option>
            <option value="magic">Magic</option>
          </select></div>
          <div><label for="ranged-elem-damage" class="small-label">Elem dmg</label><input type="number" id="ranged-elem-damage" min="0" value="0" placeholder="0"></div>
          <div><label for="ranged-bane" class="small-label">Bane dmg</label><input type="number" id="ranged-bane" min="0" value="0" placeholder="0"></div>
        </div>
      </details>
    </section>

    <section class="section--core">
      <h2>Arrow type</h2>
      <div class="item-search-wrap">
        <label for="arrow-item-search">Search items (API)</label>
        <input type="text" id="arrow-item-search" placeholder="Type 3+ characters to search..." autocomplete="off">
        <div id="arrow-item-search-list" class="item-search-list" role="listbox"></div>
      </div>
      <div class="row">
        <div><label for="arrow-damage" class="small-label">Damage</label><input type="number" id="arrow-damage" min="0" value="5" placeholder="e.g. 5"></div>
        <div><label for="arrow-elem-type" class="small-label">Elemental type</label><select id="arrow-elem-type">
          <option value="">None</option>
          <option value="fire">Fire</option>
          <option value="cold">Cold</option>
          <option value="poison">Poison</option>
          <option value="disease">Disease</option>
          <option value="magic">Magic</option>
        </select></div>
        <div><label for="arrow-elem-damage" class="small-label">Elem dmg</label><input type="number" id="arrow-elem-damage" min="0" value="0" placeholder="0"></div>
      </div>
    </section>

    <section class="section--core">
      <h2>Character (ranged)</h2>
      <label for="ranged-level">Level</label>
      <input type="number" id="ranged-level" min="1" max="65" value="60" placeholder="60">
      <label for="ranged-haste">Total haste (%)</label>
      <input type="number" id="ranged-haste" min="0" value="99" placeholder="e.g. 99">
      <div class="row">
        <div><label for="ranged-worn-attack" class="small-label">Worn attack</label><input type="number" id="ranged-worn-attack" min="0" value="0" placeholder="0"></div>
        <div><label for="ranged-spell-attack" class="small-label">Spell attack</label><input type="number" id="ranged-spell-attack" min="0" value="0" placeholder="0"></div>
      </div>
      <details class="collapse-secondary">
        <summary class="collapse-summary">Archery mastery, options</summary>
        <label>Archery Mastery</label>
        <div class="radio-group">
          <label><input type="radio" name="archery-mastery" value="1"> 1</label>
          <label><input type="radio" name="archery-mastery" value="2"> 2</label>
          <label><input type="radio" name="archery-mastery" value="3" checked> 3</label>
        </div>
        <p class="hint">AA Archery Mastery rank (1, 2, or 3).</p>
        <label class="checkbox-label"><input type="checkbox" id="mob-stationary" checked> Mob stationary</label>
        <p class="hint">When checked, target is not moving (affects hit/damage if sim uses it).</p>
        <label class="checkbox-label"><input type="checkbox" id="use-walled-mob-penalty"> Use Walled Mob Penalty</label>
        <p class="hint">When checked, the report tracks damage lost due to wall penalty vs a standard hit.</p>
      </details>
    </section>

    <section class="section--core">
      <h2>Target & Fight (ranged)</h2>
      <div class="row">
        <div><label for="ranged-target-ac" class="small-label">Target AC</label><input type="number" id="ranged-target-ac" min="1" value="300" placeholder="300"></div>
        <div><label for="ranged-mob-level" class="small-label">Mob level</label><input type="number" id="ranged-mob-level" min="1" max="70" value="60" placeholder="60"></div>
      </div>
      <div class="row">
        <div><label for="ranged-duration" class="small-label">Fight duration (sec)</label><input type="number" id="ranged-duration" min="1" value="6000" placeholder="6000"></div>
        <div><label for="ranged-runs" class="small-label">Number of runs</label><input type="number" id="ranged-runs" min="1" value="20" placeholder="20"></div>
      </div>
      <details class="collapse-secondary">
        <summary class="collapse-summary">Resistances &amp; bane options</summary>
        <label>Target resistances (for elemental damage)</label>
        <div class="row">
          <div><label for="ranged-target-mr" class="small-label">MR</label><input type="number" id="ranged-target-mr" min="0" value="35" placeholder="35"></div>
          <div><label for="ranged-target-fr" class="small-label">FR</label><input type="number" id="ranged-target-fr" min="0" value="35" placeholder="35"></div>
          <div><label for="ranged-target-cr" class="small-label">CR</label><input type="number" id="ranged-target-cr" min="0" value="35" placeholder="35"></div>
          <div><label for="ranged-target-pr" class="small-label">PR</label><input type="number" id="ranged-target-pr" min="0" value="35" placeholder="35"></div>
          <div><label for="ranged-target-dr" class="small-label">DR</label><input type="number" id="ranged-target-dr" min="0" value="35" placeholder="35"></div>
        </div>
        <p class="hint">Magic, Fire, Cold, Poison, Disease.</p>
        <label class="checkbox-label"><input type="checkbox" id="ranged-apply-bane"> Apply Bane Damage</label>
        <p class="hint">When checked, ranged weapon bane damage is added to base damage.</p>
      </details>
      <button type="button" id="btn-run-ranged">Run simulation</button>
    </section>
  </div>
  </div>
  </div>

  <section class="report-section">
    <h2>Report</h2>
    <div id="report">Run a simulation to see the report.</div>
  </section>

  <details id="item-search-debug" class="item-search-debug" style="margin-top: 0.75rem; padding: 0.5rem; background: var(--panel); border: 1px solid var(--border); border-radius: 4px;">
    <summary style="cursor: pointer; font-size: 0.85rem; color: var(--muted);">Item search debug</summary>
    <pre id="item-search-debug-content" style="margin: 0.5rem 0 0; font-size: 0.8rem; color: var(--muted); white-space: pre-wrap; word-break: break-word;">Select an item from search to see API itemType and mapped type.</pre>
  </details>
  </div>

  <aside class="histogram-aside">
    <section class="histogram-panel">
      <h2>Histograms</h2>
      <div id="histogram-container" class="histogram-container"></div>
    </section>
    <section class="histogram-panel" id="sim-history-section">
      <h2>Simulation history</h2>
      <p class="hint" style="margin-top: -0.5rem; margin-bottom: 0.5rem;">Runs from this session (newest first).</p>
      <div id="sim-history-list"></div>
      <button type="button" id="sim-history-clear" class="sim-history-clear-btn">Clear history</button>
    </section>
  </aside>
  </div>

  <section style="margin-top: 1rem;">
    <h2>Version log</h2>
    <ul style="font-size: 0.9rem; color: var(--muted); margin: 0; padding-left: 1.25rem;">
      <li><strong>0.8</strong> — Added UI improvements, added elemental and bane damage.</li>
      <li><strong>0.7</strong> — Added Ranged Combat simulations.</li>
      <li><strong>0.6</strong> — Multi-run report: all values (including crit hits and crit damage gain) are averages per run, not cumulative. Clear distinction between offense skill (0–255, to-hit only) and offense rating (skill + STR + worn + spell, used for damage): UI labels, report lines, and hint; report shows Offense skill, Offense rating (for damage), and Offense rating from stats (STR).</li>
      <li><strong>0.5</strong> — Added logging to simulation operations.</li>
      <li><strong>0.4</strong> — Fistweaving (Monk + 2H): optional offhand 9-dmg rounds, can double attack, no proc; DPS in report. Proc rate: PPM-based formula (~2 PPM at 255 DEX), uses effective delay. Rogue backstab: Backstab skill field (default 225, cap 255), client formula (skill×0.02+2)×weapon damage, level-based minHit; Backstab mod %; effective backstab skill in report when mod used. Removed classes: Necromancer, Enchanter, Shaman, Druid, Cleric, Magician, Wizard.</li>
      <li><strong>0.3</strong> — Unequipped quick select; Behind default; duration 6000s, runs 20; Ambidexterity AA checkbox; main weapon default Unequipped.</li>
      <li><strong>0.2</strong> — Worn/spell attack inputs; toHit excludes worn/spell; offense skill 252 for toHit; removed Offense override; default duration 2400s; histogram always shown; displayed attack &amp; stat contribution in report.</li>
      <li><strong>0.1</strong> — Initial release. Melee combat sim with DA/DW, damage bonus, crits, procs, histogram.</li>
    </ul>
  </section>

  <p class="muted" style="margin-top: 1.5rem; font-size: 0.85rem;">Made by Gabbiz</p>

  <script src="combat.js"></script>
  <script src="weaponSkillCaps.js"></script>
  <script src="itemSearch.js"></script>
  <!-- Load itemSearchConfig.js only locally (file is gitignored; on Vercel we use /api/item-search with env key) -->
  <script>
    if (location.hostname === 'localhost' || location.protocol === 'file:') {
      document.write('<script src="itemSearchConfig.js"><\x2Fscript>');
    }
  </script>
  <script>
    (function () {
      if (typeof ItemSearch !== 'undefined') {
        if (typeof ITEM_SEARCH_CONFIG !== 'undefined') {
          ItemSearch.setConfig(ITEM_SEARCH_CONFIG);
        } else {
          ItemSearch.setConfig({ proxyUrl: '/api/item-search' });
        }
      }
      const $ = (id) => document.getElementById(id);

      // ----- Background usage log (no UI). Set USAGE_LOG_URL to your endpoint to enable.
      // e.g. local: 'http://localhost:8765/log'  or Vercel: 'https://dps-sim.vercel.app/api/log'
      // Summary (total runs, unique users, run log): https://dps-sim.vercel.app/api/summary
      const USAGE_LOG_URL = 'https://dps-sim.vercel.app/api/log';
      const USAGE_LOG_STORAGE_KEY = 'dps_sim_uid';
      function getOrCreateAnonymousUserId() {
        try {
          let uid = localStorage.getItem(USAGE_LOG_STORAGE_KEY);
          if (!uid) {
            uid = 'u_' + Math.random().toString(36).slice(2, 11) + '_' + Date.now().toString(36);
            localStorage.setItem(USAGE_LOG_STORAGE_KEY, uid);
          }
          return uid;
        } catch (e) { return 'anon'; }
      }
      function logUsage(payload) {
        if (!USAGE_LOG_URL || typeof fetch === 'undefined') return;
        try {
          const body = JSON.stringify(payload);
          if (navigator.sendBeacon && navigator.sendBeacon(USAGE_LOG_URL, new Blob([body], { type: 'application/json' }))) return;
          fetch(USAGE_LOG_URL, { method: 'POST', body, headers: { 'Content-Type': 'application/json' }, keepalive: true }).catch(function () {});
        } catch (e) {}
      }

      // When releasing: 1) Bump VERSION below. 2) Add a new <li> at the top of the Version log section above.
      const VERSION = '0.8';
      const versionEl = $('app-version');
      if (versionEl) versionEl.textContent = 'v' + VERSION;

      const SIM_HISTORY = [];
      const SIM_HISTORY_MAX = 50;

      // Weapon presets from PQDI (damage, delay decisec, proc spell name, name for sorting; type: 1hb/2hb/1hp/1hs/h2h)
      const WEAPON_PRESETS = {
        'unequipped': { damage: 0, delay: 0, proc: '', procDamage: 0, name: 'Unequipped' },
        '27315': { damage: 17, delay: 19, proc: 'Claw of Khati Sha', procDamage: 150, name: 'Fangs of Vyzh`dra', type: 'h2h' },
        '26809': { damage: 17, delay: 20, proc: 'Claw of Khati Sha', procDamage: 150, name: 'Glowing Mithril Ulak', type: 'h2h' },
        '31241': { damage: 16, delay: 19, proc: 'Strike of the Chosen', procDamage: 80, name: 'Gharn\'s Rock of Smashing', type: 'h2h' },
        '26599': { damage: 43, delay: 30, proc: 'Serpent\'s Bite', procDamage: 100, name: 'Caen\'s Bo Staff of Fury', is2H: true, type: '2hb' },
        '31242': { damage: 40, delay: 30, proc: '', procDamage: 0, name: 'Abashi\'s Rod of Disempowerment', is2H: true, type: '2hb' },
        '26849': { damage: 16, delay: 19, proc: 'Claw of Khati Sha', procDamage: 150, name: 'Fist of Acrylia', type: 'h2h' },
        '26860': { damage: 15, delay: 19, proc: 'Claw of Khati Sha', procDamage: 150, name: 'Fist of Glowing Acrylia', type: 'h2h' },
        '5776': { damage: 15, delay: 18, proc: 'Engulfing Roots', procDamage: 160, name: 'Fist of Nature', type: 'h2h' },
        '1154': { damage: 12, delay: 18, proc: 'Anarchy', procDamage: 288, name: 'Sceptre of Destruction', type: '1hb' },
        '27324': { damage: 45, delay: 44, proc: 'Avatar', procDamage: 0, name: 'Primal Velium Brawl Stick', is2H: true, type: '2hb' },
        '27320': { damage: 15, delay: 20, proc: 'Avatar', procDamage: 0, name: 'Primal Velium Fist Wraps', type: 'h2h' },
        '28974': { damage: 10, delay: 40, proc: '', procDamage: 0, name: 'Great Maul of Slaughter', is2H: true, type: '2hb', elemType: 'disease', elemDamage: 5, baneDamage: 55 },
        '28923': { damage: 1, delay: 18, proc: '', procDamage: 0, name: 'Great Mace of Slaughter', type: '1hb', elemType: 'magic', elemDamage: 1, baneDamage: 16 },
        '28831': { damage: 16, delay: 22, proc: 'Terrifying Darkness', procDamage: 100, name: 'Blackout', type: '1hp' },
        '6631': { damage: 44, delay: 40, proc: 'One Hundred Blows', procDamage: 120, name: 'Ton Po\'s Bo Stick of Understanding', is2H: true, type: '2hb' },
        '6639': { damage: 29, delay: 30, proc: 'One Hundred Blows', procDamage: 120, name: 'Tranquil Staff', is2H: true, type: '2hb' },
        '6646': { damage: 28, delay: 30, proc: '', procDamage: 0, name: 'Peacebringer', is2H: true, type: '2hb' },
        '6612': { damage: 9, delay: 18, proc: '', procDamage: 0, name: 'Jade Mace', type: '1hb' },
        '32333': { damage: 12, delay: 23, proc: '', procDamage: 0, name: 'Goranga Spiked Club', type: '1hb' },
        '6610': { damage: 17, delay: 28, proc: 'Major Shielding', procDamage: 0, name: 'Stave of Shielding', is2H: true, type: '2hb' },
        '31224': { damage: 15, delay: 19, proc: 'Feast of Blood', procDamage: 90, name: 'Mrylokar\'s Dagger of Vengeance', type: '1hp' },
        '2509': { damage: 15, delay: 20, proc: 'Combust', procDamage: 182, name: 'Massive Heartwood Thorn', type: '1hp' },
        '31379': { damage: 14, delay: 18, proc: '', procDamage: 0, name: 'Claw of Lightning', type: '1hs' },
        '31301': { damage: 13, delay: 17, proc: '', procDamage: 0, name: 'Vyemm\'s Fang', type: '1hp' },
        '1158': { damage: 13, delay: 18, proc: 'Thunder Strike', procDamage: 263, name: 'Salindrite Dagger', type: '1hp' },
        '11057': { damage: 15, delay: 25, proc: '', procDamage: 0, name: 'Ragebringer', type: '1hp' },
        '28806': { damage: 16, delay: 20, proc: 'Khalshazar\'s Deceit', procDamage: 0, name: 'Khalshazar', type: '1hp' },
        '28805': { damage: 16, delay: 21, proc: '', procDamage: 0, name: 'Bloodbath', type: '1hp' },
        '26585': { damage: 16, delay: 19, proc: 'Serpent\'s Bite', procDamage: 100, name: 'Acrylia Handled Broadsword', type: '1hs' },
      };

      // Ranged weapon presets (PQDI: https://www.pqdi.cc/item/...)
      const RANGED_WEAPON_PRESETS = {
        '25208': { damage: 43, delay: 45, proc: 'Torment', procDamage: 0, name: 'War Bow of Rallos Zek' },
        '27317': { damage: 39, delay: 45, proc: '', procDamage: 0, name: 'Ssraeshzian Longbow' },
        '28989': { damage: 33, delay: 35, proc: 'Spirit Curse', procDamage: 0, name: 'Bow of Shadows' },
        '27326': { damage: 33, delay: 35, proc: 'Avatar', procDamage: 0, name: 'Primal Velium Reinforced Bow' },
      };
      const RANGED_WEAPON_PRESET_IDS = Object.keys(RANGED_WEAPON_PRESETS).sort(function (a, b) {
        return (RANGED_WEAPON_PRESETS[b].damage - RANGED_WEAPON_PRESETS[a].damage) || (RANGED_WEAPON_PRESETS[a].name || '').localeCompare(RANGED_WEAPON_PRESETS[b].name || '');
      });

      // Arrow presets (PQDI) – base damage + elemental from elemdmgtype/elemdmgamt
      const ARROW_PRESETS = {
        '24493': { damage: 11, name: 'Blessed Champion Arrows', elemType: 'fire', elemDamage: 4 },
        '24488': { damage: 11, name: 'Mithril Champion Arrows', elemType: 'fire', elemDamage: 3 },
        '10762': { damage: 10, name: 'Ice Tipped Acrylia Arrow', elemType: 'cold', elemDamage: 4 },
        '10761': { damage: 10, name: 'Shadow Tipped Acrylia Arrow', elemType: 'magic', elemDamage: 4 },
        '10760': { damage: 10, name: 'Flame Tipped Acrylia Arrow', elemType: 'fire', elemDamage: 4 },
      };
      const ARROW_PRESET_IDS = Object.keys(ARROW_PRESETS).sort(function (a, b) {
        return (ARROW_PRESETS[b].damage - ARROW_PRESETS[a].damage) || (ARROW_PRESETS[a].name || '').localeCompare(ARROW_PRESETS[b].name || '');
      });

      const WEAPON_PRESET_IDS = Object.keys(WEAPON_PRESETS).filter(function (id) { return id !== 'unequipped'; }).sort(function (a, b) {
        const typeOrder = { '2hb': 0, '1hb': 1, '1hp': 2, '1hs': 3, 'h2h': 4 };
        const pa = WEAPON_PRESETS[a];
        const pb = WEAPON_PRESETS[b];
        const ta = typeOrder[pa.type] !== undefined ? typeOrder[pa.type] : 99;
        const tb = typeOrder[pb.type] !== undefined ? typeOrder[pb.type] : 99;
        if (ta !== tb) return ta - tb;
        return (pa.name || '').localeCompare(pb.name || '');
      });

      function weaponOptionLabel(id) {
        const p = WEAPON_PRESETS[id];
        if (!p) return '';
        const stats = p.damage + '/' + p.delay;
        const desc = p.name + ' (' + stats + (p.proc ? ', ' + p.proc : '') + ')';
        return (p.type ? p.type + ' ' : '') + desc;
      }

      function isW1TwoHanded() {
        const overrideEl = $('w1-is2h-override');
        if (overrideEl && overrideEl.value === '1') return true;
        const presetEl = $('w1-preset');
        const presetId = presetEl && presetEl.value;
        if (!presetId) return false;
        const p = WEAPON_PRESETS[presetId] || null;
        const type2H = p && p.type && (p.type.toLowerCase() === '2hb' || p.type.toLowerCase() === '2hs' || p.type.toLowerCase() === '2hp' || p.type.toLowerCase() === 'bow');
        return !!(p && (p.is2H || type2H));
      }
      let w1DisplayName = '';
      let w2DisplayName = '';
      let w1FromItemSearch = false;
      let w2FromItemSearch = false;
      let rangedFromItemSearch = false;
      let rangedWeaponDisplayName = '';
      let arrowFromItemSearch = false;
      let arrowDisplayName = '';
      let w1WeaponType = null;
      let w2WeaponType = null;

      function formatSkillLabel(key) {
        if (key === '1hp' || key === '2hp') return 'Piercing';
        if (key === 'undefined') return 'UNDEFINED';
        return (key || '').toUpperCase();
      }
      function updateWeaponNameDisplay(prefix) {
        const span = $(prefix + '-weapon-name');
        const skillEl = $(prefix + '-weapon-skill');
        if (!span) return;
        if (prefix === 'w2' && isW1TwoHanded()) {
          span.textContent = 'Unavailable';
          if (skillEl) skillEl.textContent = '';
          return;
        }
        const dmg = parseInt($(prefix + '-damage').value, 10) || 0;
        const dly = parseInt($(prefix + '-delay').value, 10) || 0;
        const isUnequipped = dmg <= 0 || dly <= 0;
        let name = isUnequipped ? 'Unequipped' : ((prefix === 'w1' ? w1DisplayName : w2DisplayName) || 'Custom');
        const skillKey = skillKeyForCap(prefix === 'w1' ? w1WeaponType : w2WeaponType, prefix === 'w1' && isW1TwoHanded());
        span.textContent = name;
        if (skillEl) skillEl.textContent = (name && name !== 'Unequipped') ? formatSkillLabel(skillKey) : '';
      }

      function updateWeaponIcon(prefix, iconNum) {
        const wrapEl = $(prefix + '-weapon-icon-wrap');
        const imgEl = $(prefix + '-weapon-icon');
        if (!wrapEl || !imgEl) return;
        if (iconNum != null && iconNum > 0) {
          imgEl.src = 'icons/' + iconNum + '.gif';
          imgEl.alt = 'Weapon icon';
          wrapEl.style.display = '';
        } else {
          imgEl.src = '';
          imgEl.alt = '';
          wrapEl.style.display = 'none';
        }
      }

      function applyWeaponPreset(prefix, id) {
        const p = id ? WEAPON_PRESETS[id] : null;
        const pType2H = p && p.type && (p.type.toLowerCase() === '2hb' || p.type.toLowerCase() === '2hs' || p.type.toLowerCase() === '2hp' || p.type.toLowerCase() === 'bow');
        if (prefix === 'w1') {
          w1WeaponType = (p && p.type) ? p.type : null;
          w1FromItemSearch = false;
          if (id === 'unequipped') w1DisplayName = '';
          const overrideEl = $('w1-is2h-override');
          if (overrideEl) overrideEl.value = (p && (p.is2H || pType2H)) ? '1' : '0';
        }
        if (prefix === 'w2') { w2WeaponType = (p && p.type) ? p.type : null; w2FromItemSearch = false; if (id === 'unequipped') w2DisplayName = ''; }
        if (p) {
          $(prefix + '-damage').value = p.damage;
          $(prefix + '-delay').value = p.delay;
          $(prefix + '-proc').value = p.proc || '';
          const procDmgEl = $(prefix + '-proc-damage');
          if (procDmgEl) procDmgEl.value = (p.procDamage != null ? p.procDamage : 0) || '';
          const elemTypeEl = $(prefix + '-elem-type');
          if (elemTypeEl) elemTypeEl.value = p.elemType || '';
          const elemDamageEl = $(prefix + '-elem-damage');
          if (elemDamageEl) elemDamageEl.value = (p.elemDamage != null ? p.elemDamage : 0) || '';
          const baneEl = $(prefix + '-bane');
          if (baneEl) baneEl.value = (p.baneDamage != null ? p.baneDamage : 0) || '';
          if (prefix === 'w1' && (p.is2H || pType2H)) {
            applyWeaponPreset('w2', 'unequipped');
          }
          if (prefix === 'w1') {
            updateWeapon2Disabled();
            updateFistweavingVisibility();
          }
        }
        updateWeaponNameDisplay(prefix);
        updateWeaponIcon(prefix, null);
        if (prefix === 'w1' && id === 'unequipped') updateWeaponNameDisplay('w2');
      }

      // Class-specific defaults and modifiers (EQMacEmu / attack.cpp style)
      const CLASSES = {
        warrior:   { toHitBonus: 24, doubleAttack: 250, dualWield: 245, name: 'Warrior' },
        paladin:   { toHitBonus: 0,  doubleAttack: 200, dualWield: 0,   name: 'Paladin' },
        ranger:    { toHitBonus: 0,  doubleAttack: 200, dualWield: 252, name: 'Ranger' },
        shadowknight: { toHitBonus: 0, doubleAttack: 200, dualWield: 0, name: 'Shadowknight' },
        monk:      { toHitBonus: 0,  doubleAttack: 250, dualWield: 252, name: 'Monk' },
        rogue:     { toHitBonus: 0,  doubleAttack: 252, dualWield: 252, name: 'Rogue' },
        bard:      { toHitBonus: 0,  doubleAttack: 0, dualWield: 245, name: 'Bard' },
        beastlord: { toHitBonus: 0,  doubleAttack: 0, dualWield: 252,   name: 'Beastlord' },
      };

      function getWeapon(prefix) {
        const damage = parseInt($(prefix + '-damage').value, 10) || 0;
        const delay = parseInt($(prefix + '-delay').value, 10) || 0;
        const proc = $(prefix + '-proc').value.trim() || null;
        const procDamageEl = $(prefix + '-proc-damage');
        const procSpellDamage = procDamageEl && procDamageEl.value !== '' ? parseInt(procDamageEl.value, 10) : 0;
        const minDmgRaw = $(prefix + '-min');
        const maxDmgRaw = $(prefix + '-max');
        const minDmg = minDmgRaw && minDmgRaw.value !== '' ? parseInt(minDmgRaw.value, 10) : null;
        const maxDmg = maxDmgRaw && maxDmgRaw.value !== '' ? parseInt(maxDmgRaw.value, 10) : null;
        const is2H = prefix === 'w1' && isW1TwoHanded();
        const elemTypeEl = $(prefix + '-elem-type');
        const elemDamageEl = $(prefix + '-elem-damage');
        const elemType = elemTypeEl && elemTypeEl.value && elemTypeEl.value.trim() ? elemTypeEl.value.trim() : undefined;
        const elemDamage = elemDamageEl && elemDamageEl.value !== '' ? (parseInt(elemDamageEl.value, 10) || 0) : 0;
        const baneEl = $(prefix + '-bane');
        const baneDamage = baneEl && baneEl.value !== '' ? (parseInt(baneEl.value, 10) || 0) : 0;
        const out = { damage, delay, procSpell: proc, procSpellDamage: procSpellDamage || 0, minDmg, maxDmg, is2H, baneDamage };
        if (elemType && elemDamage > 0) { out.elemType = elemType; out.elemDamage = elemDamage; }
        return out;
      }

      function run() {
        const weapon1 = getWeapon('w1');
        const weapon2 = getWeapon('w2');
        if ($('apply-bane').checked) {
          if (weapon1.baneDamage) weapon1.damage += weapon1.baneDamage;
          if (weapon2.baneDamage) weapon2.damage += weapon2.baneDamage;
        }
        const hasMainHand = weapon1.damage >= 1 && weapon1.delay >= 10;
        const dualWieldSkillForValidation = parseInt($('dual-wield').value, 10) || 0;
        const hasOffhand = weapon2.damage >= 1 && weapon2.delay >= 10 && dualWieldSkillForValidation >= 1;
        if (!hasMainHand && !hasOffhand) {
          $('report').textContent = 'Set Weapon 1 (Damage >= 1, Delay >= 10) or Weapon 2 with Dual Wield skill.';
          return;
        }

        const hastePercent = parseFloat($('haste').value) || 0;
        const wornAttack = parseInt($('worn-attack').value, 10) || 0;
        const spellAttack = parseInt($('spell-attack').value, 10) || 0;
        let doubleAttackSkill = parseInt($('double-attack').value, 10) || 0;
        let dualWieldSkill = parseInt($('dual-wield').value, 10) || 0;
        const level = parseInt($('level').value, 10) || 60;
        const targetAC = parseInt($('target-ac').value, 10) || 550;
        const mobLevel = parseInt($('mob-level').value, 10) || 60;
        const targetMR = parseInt($('target-mr').value, 10) || 35;
        const targetFR = parseInt($('target-fr').value, 10) || 35;
        const targetCR = parseInt($('target-cr').value, 10) || 35;
        const targetPR = parseInt($('target-pr').value, 10) || 35;
        const targetDR = parseInt($('target-dr').value, 10) || 35;
        const durationSec = parseInt($('duration').value, 10) || 6000;
        const str = parseInt($('str').value, 10) || 255;
        const runs = Math.max(1, Math.min(1000, parseInt($('runs').value, 10) || 20));
        const dex = parseInt($('dex').value, 10) || 255;
        const fromBehind = document.querySelector('input[name="from-behind"]:checked').value === '1';
        const critChanceMult = parseInt($('crit-chance-aa').value, 10) || 0;
        const classId = ($('class').value || '').toLowerCase();
        const classConfig = classId ? CLASSES[classId] : null;
        const toHitBonus = (classConfig && classConfig.toHitBonus) ? classConfig.toHitBonus : 0;
        const specialAttacks = $('special-attacks').checked;

        const useWeapon2 = weapon2.damage > 0 && weapon2.delay > 0 && dualWieldSkill > 0;

        const offenseSkill = Math.min(255, Math.max(0, parseInt($('offense-skill').value, 10) || 252));
        const skillKey = hasMainHand
          ? skillKeyForCap(w1WeaponType, weapon1.is2H)
          : skillKeyForCap(w2WeaponType, weapon2.is2H);
        let weaponSkillForToHit = getWeaponSkillInput(skillKey);
        if (weaponSkillForToHit <= 0 && typeof WeaponSkillCaps !== 'undefined' && classId && level) {
          weaponSkillForToHit = WeaponSkillCaps.getCapForSimClass(classId, skillKey, level) || undefined;
        }
        if (weaponSkillForToHit <= 0) weaponSkillForToHit = undefined;
        const options = {
          weapon1: hasMainHand ? { damage: weapon1.damage, delay: weapon1.delay, procSpell: weapon1.procSpell, procSpellDamage: weapon1.procSpellDamage, is2H: weapon1.is2H, elemType: weapon1.elemType, elemDamage: weapon1.elemDamage } : undefined,
          weapon2: useWeapon2 ? { damage: weapon2.damage, delay: weapon2.delay, procSpell: weapon2.procSpell, procSpellDamage: weapon2.procSpellDamage, elemType: weapon2.elemType, elemDamage: weapon2.elemDamage } : undefined,
          hastePercent,
          offenseSkill,
          wornAttack,
          spellAttack,
          toHitBonus,
          ambidexterity: $('ambidexterity-aa').checked ? 32 : 0,
          doubleAttackSkill,
          dualWieldSkill: (useWeapon2 || !hasMainHand) ? dualWieldSkill : 0,
          level,
          targetAC,
          mobLevel,
          targetMR, targetFR, targetCR, targetPR, targetDR,
          fightDurationSec: durationSec,
          dex,
          str,
          fromBehind,
          specialAttacks,
          classId: classId || undefined,
          weaponSkillForToHit: weaponSkillForToHit,
          backstabModPercent: classId === 'rogue' ? (parseInt($('backstab-mod').value, 10) || 0) : undefined,
          backstabSkill: classId === 'rogue' ? (parseInt($('backstab-skill').value, 10) || 0) : undefined,
          fistweaving: hasMainHand && classId === 'monk' && weapon1.is2H && $('fistweaving').checked,
          critChanceMult: critChanceMult || undefined,
        };

        const reports = [];
        for (let i = 0; i < runs; i++) {
          options.seed = runs === 1 ? undefined : (Date.now() + i);
          const r = EQCombat.runFight(options);
          if (r.error) {
            $('report').textContent = r.error;
            return;
          }
          reports.push(r);
        }

        let report;
        if (runs === 1) {
          report = reports[0];
        } else {
          const w1Hits = reports.reduce((s, r) => s + r.weapon1.hits, 0);
          const w2Hits = reports.reduce((s, r) => s + r.weapon2.hits, 0);
          const w1Mins = reports.map(r => r.weapon1.minDamage).filter(m => m != null && m !== Infinity);
          const w2Mins = reports.map(r => r.weapon2.minDamage).filter(m => m != null && m !== Infinity);
          const w1HitStats = reports.map(r => r.weapon1.hitStats).filter(Boolean);
          const w2HitStats = reports.map(r => r.weapon2.hitStats).filter(Boolean);
          report = {
            weapon1: {
              rounds: Math.round(reports.reduce((s, r) => s + (r.weapon1.rounds != null ? r.weapon1.rounds : r.weapon1.swings), 0) / runs),
              single: Math.round(reports.reduce((s, r) => s + (r.weapon1.single || 0), 0) / runs),
              double: Math.round(reports.reduce((s, r) => s + (r.weapon1.double || 0), 0) / runs),
              triple: Math.round(reports.reduce((s, r) => s + (r.weapon1.triple || 0), 0) / runs),
              swings: Math.round(reports.reduce((s, r) => s + r.weapon1.swings, 0) / runs),
              hits: Math.round(reports.reduce((s, r) => s + r.weapon1.hits, 0) / runs),
              totalDamage: Math.round(reports.reduce((s, r) => s + r.weapon1.totalDamage, 0) / runs),
              maxDamage: Math.round(reports.reduce((s, r) => s + r.weapon1.maxDamage, 0) / runs),
              minDamage: w1Mins.length ? Math.min(...w1Mins) : null,
              procs: Math.round(reports.reduce((s, r) => s + (r.weapon1.procs || 0), 0) / runs),
              procDamageTotal: Math.round(reports.reduce((s, r) => s + (r.weapon1.procDamageTotal || 0), 0) / runs),
              hitStats: w1HitStats.length ? {
                min: w1Mins.length ? Math.min(...w1Mins) : null,
                max: Math.max(...reports.map(r => r.weapon1.maxDamage)),
                mean: w1Hits ? reports.reduce((s, r) => s + r.weapon1.totalDamage, 0) / w1Hits : null,
                median: w1HitStats.reduce((s, h) => s + (h.median != null ? h.median : 0), 0) / w1HitStats.length,
                mode: w1HitStats.reduce((s, h) => s + (h.mode != null ? h.mode : 0), 0) / w1HitStats.length,
              } : {},
            },
            weapon2: {
              rounds: Math.round(reports.reduce((s, r) => s + (r.weapon2.rounds != null ? r.weapon2.rounds : r.weapon2.swings), 0) / runs),
              single: Math.round(reports.reduce((s, r) => s + (r.weapon2.single || 0), 0) / runs),
              double: Math.round(reports.reduce((s, r) => s + (r.weapon2.double || 0), 0) / runs),
              triple: 0,
              swings: Math.round(reports.reduce((s, r) => s + r.weapon2.swings, 0) / runs),
              hits: Math.round(reports.reduce((s, r) => s + r.weapon2.hits, 0) / runs),
              totalDamage: Math.round(reports.reduce((s, r) => s + r.weapon2.totalDamage, 0) / runs),
              maxDamage: Math.round(reports.reduce((s, r) => s + r.weapon2.maxDamage, 0) / runs),
              minDamage: w2Mins.length ? Math.min(...w2Mins) : null,
              procs: Math.round(reports.reduce((s, r) => s + (r.weapon2.procs || 0), 0) / runs),
              procDamageTotal: Math.round(reports.reduce((s, r) => s + (r.weapon2.procDamageTotal || 0), 0) / runs),
              hitStats: w2HitStats.length ? {
                min: w2Mins.length ? Math.min(...w2Mins) : null,
                max: reports.some(r => r.weapon2.hits > 0) ? Math.max(...reports.map(r => r.weapon2.maxDamage)) : null,
                mean: w2Hits ? reports.reduce((s, r) => s + r.weapon2.totalDamage, 0) / w2Hits : null,
                median: w2HitStats.reduce((s, h) => s + (h.median != null ? h.median : 0), 0) / w2HitStats.length,
                mode: w2HitStats.reduce((s, h) => s + (h.mode != null ? h.mode : 0), 0) / w2HitStats.length,
              } : {},
            },
            durationSec,
            totalDamage: Math.round(reports.reduce((s, r) => s + r.totalDamage, 0) / runs),
            damageBonus: reports[0].damageBonus != null ? reports[0].damageBonus : 0,
            damageBonusTotal: Math.round(reports.reduce((s, r) => s + (r.damageBonusTotal || 0), 0) / runs),
            calculatedToHit: reports[0].calculatedToHit,
            offenseSkill: reports[0].offenseSkill,
            offenseRating: reports[0].offenseRating,
            offenseRatingFromStr: reports[0].offenseRatingFromStr,
            displayedAttack: reports[0].displayedAttack,
            baseDamageCap: reports[0].baseDamageCap || null,
            critHits: Math.round(reports.reduce((s, r) => s + (r.critHits || 0), 0) / runs),
            critDamageGain: Math.round(reports.reduce((s, r) => s + (r.critDamageGain || 0), 0) / runs),
            special: reports[0].special
              ? {
                  name: reports[0].special.name,
                  count: Math.round(reports.reduce((s, r) => s + (r.special ? r.special.count : 0), 0) / runs),
                  attempts: reports[0].special.attempts != null ? Math.round(reports.reduce((s, r) => s + (r.special && r.special.attempts != null ? r.special.attempts : 0), 0) / runs) : undefined,
                  hits: reports[0].special.hits != null ? Math.round(reports.reduce((s, r) => s + (r.special && r.special.hits != null ? r.special.hits : 0), 0) / runs) : undefined,
                  totalDamage: Math.round(reports.reduce((s, r) => s + (r.special ? r.special.totalDamage : 0), 0) / runs),
                  maxDamage: Math.round(reports.reduce((s, r) => s + (r.special ? r.special.maxDamage : 0), 0) / runs),
                  doubleBackstabs: reports[0].special.doubleBackstabs !== undefined ? Math.round(reports.reduce((s, r) => s + (r.special && r.special.doubleBackstabs != null ? r.special.doubleBackstabs : 0), 0) / runs) : undefined,
                  backstabSkill: reports[0].special.backstabSkill,
                  backstabModPercent: reports[0].special.backstabModPercent,
                  hitList: reports[0].special.hitList,
                }
              : null,
            fistweaving: reports[0].fistweaving
              ? {
                  rounds: Math.round(reports.reduce((s, r) => s + (r.fistweaving ? r.fistweaving.rounds : 0), 0) / runs),
                  swings: Math.round(reports.reduce((s, r) => s + (r.fistweaving ? r.fistweaving.swings : 0), 0) / runs),
                  hits: Math.round(reports.reduce((s, r) => s + (r.fistweaving ? r.fistweaving.hits : 0), 0) / runs),
                  totalDamage: Math.round(reports.reduce((s, r) => s + (r.fistweaving ? r.fistweaving.totalDamage : 0), 0) / runs),
                  maxDamage: Math.round(reports.reduce((s, r) => s + (r.fistweaving ? r.fistweaving.maxDamage : 0), 0) / runs),
                  single: Math.round(reports.reduce((s, r) => s + (r.fistweaving ? (r.fistweaving.single || 0) : 0), 0) / runs),
                  double: Math.round(reports.reduce((s, r) => s + (r.fistweaving ? (r.fistweaving.double || 0) : 0), 0) / runs),
                }
              : null,
          };
        }

        const w1Name = (w1FromItemSearch && w1DisplayName ? w1DisplayName : (weapon1.damage + 'd/' + weapon1.delay));
        const w2Name = useWeapon2 ? (w2FromItemSearch && w2DisplayName ? w2DisplayName : (weapon2.damage + 'd/' + weapon2.delay)) : '—';
        const w1Label = hasMainHand ? `Weapon 1: ${w1Name} (${weapon1.damage}d / ${weapon1.delay} delay${weapon1.procSpell ? ' / ' + weapon1.procSpell : ''})` : 'Main hand (unequipped)';
        const w2Label = useWeapon2
          ? `Weapon 2: ${w2Name} (${weapon2.damage}d / ${weapon2.delay} delay${weapon2.procSpell ? ' / ' + weapon2.procSpell : ''})`
          : 'Weapon 2';
        let reportText = EQCombat.formatReport(report, w1Label, w2Label, runs);
        if (typeof WeaponSkillCaps !== 'undefined' && classId && level) {
          const capSkillKey = skillKeyForCap(w1WeaponType, weapon1.is2H);
          const skillCap = WeaponSkillCaps.getCapForSimClass(classId, capSkillKey, level);
          reportText = '  Weapon skill cap (' + capSkillKey + '): ' + skillCap + ' (Quarm/TAKP)\n\n' + reportText;
        }
        $('report').textContent = reportText;

        const dpsEl = $('dps-value');
        if (dpsEl && report.durationSec) dpsEl.textContent = (report.totalDamage / report.durationSec).toFixed(2);

        const histContainer = $('histogram-container');
        if (reports.length > 0) {
          renderHistogram(histContainer, reports[0], w1Label, w2Label);
        } else {
          histContainer.innerHTML = '';
        }

        const totalAttack = report.displayedAttack != null ? report.displayedAttack : report.offenseRating;
        const weaponDps = report.durationSec > 0 ? (report.totalDamage / report.durationSec) : 0;
        SIM_HISTORY.unshift({
          weapon1: w1Name,
          weapon2: useWeapon2 ? w2Name : '—',
          attack: totalAttack,
          mobAC: targetAC,
          dps: weaponDps
        });
        if (SIM_HISTORY.length > SIM_HISTORY_MAX) SIM_HISTORY.pop();
        renderSimHistory();

        if (USAGE_LOG_URL) {
          logUsage({
            event: 'sim_run',
            v: VERSION,
            uid: getOrCreateAnonymousUserId(),
            ts: Date.now(),
            w1: { name: w1Name, damage: weapon1.damage, delay: weapon1.delay, is2H: !!weapon1.is2H },
            w2: useWeapon2 ? { name: w2Name, damage: weapon2.damage, delay: weapon2.delay } : null,
            classId: classId || '',
            durationSec,
            runs,
            totalDamage: report.totalDamage,
            specialAttacks: !!specialAttacks,
            fistweaving: !!(classId === 'monk' && weapon1.is2H && $('fistweaving').checked),
          });
        }
      }

      function buildHistogramBuckets(hitList, maxBins) {
        if (!hitList || hitList.length === 0) return { buckets: [], maxCount: 0 };
        const min = Math.min.apply(null, hitList);
        const max = Math.max.apply(null, hitList);
        const range = max - min + 1;
        const binWidth = Math.max(1, Math.ceil(range / (maxBins || 40)));
        const numBins = Math.ceil(range / binWidth);
        const counts = new Array(numBins).fill(0);
        for (let i = 0; i < hitList.length; i++) {
          const bin = Math.min(numBins - 1, Math.floor((hitList[i] - min) / binWidth));
          counts[bin]++;
        }
        const buckets = counts.map(function (c, i) {
          return { low: min + i * binWidth, high: min + (i + 1) * binWidth - 1, count: c };
        });
        const maxCount = Math.max.apply(null, counts);
        return { buckets, maxCount };
      }

      function renderHistogram(container, report, w1Label, w2Label) {
        container.innerHTML = '';
        if (!report || !report.weapon1) return;
        const maxBins = 40;
        [ { list: report.weapon1.hitList, label: w1Label || 'Weapon 1 (Main Hand)' },
          { list: report.weapon2 && report.weapon2.hitList, label: w2Label || 'Weapon 2 (Offhand)' },
          { list: report.special && report.special.hitList, label: report.special && report.special.name }
        ].forEach(function (hand) {
          if (!hand.list || hand.list.length === 0) return;
          const section = document.createElement('div');
          section.className = 'histogram-section';
          const h3 = document.createElement('h3');
          h3.textContent = hand.label + ' — damage per swing';
          section.appendChild(h3);
          const data = buildHistogramBuckets(hand.list, maxBins);
          const chart = document.createElement('div');
          chart.className = 'histogram-chart';
          const maxCount = data.maxCount || 1;
          data.buckets.forEach(function (b) {
            const bar = document.createElement('div');
            bar.className = 'histogram-bar';
            bar.style.flex = '1 1 auto';
            const pct = maxCount > 0 ? (b.count / maxCount) * 100 : 0;
            bar.style.height = Math.max(0, pct) + '%';
            bar.title = (b.low === b.high ? b.low : b.low + '–' + b.high) + ' dmg: ' + b.count + ' hits';
            chart.appendChild(bar);
          });
          section.appendChild(chart);
          const legend = document.createElement('div');
          legend.className = 'histogram-legend';
          legend.textContent = hand.list.length + ' hits, damage range ' + Math.min.apply(null, hand.list) + '–' + Math.max.apply(null, hand.list);
          section.appendChild(legend);
          container.appendChild(section);
        });
      }

      $('btn-run').addEventListener('click', run);

      function renderSimHistory() {
        const listEl = $('sim-history-list');
        if (!listEl) return;
        if (SIM_HISTORY.length === 0) {
          listEl.innerHTML = '<p class="hint" style="margin: 0;">No runs yet this session.</p>';
          return;
        }
        const header = '<div class="sim-history-row sim-history-header"><span class="sim-history-w1">Weapon 1</span><span class="sim-history-w2">Weapon 2</span><span class="sim-history-atk">Attack</span><span class="sim-history-ac">Mob AC</span><span class="sim-history-dps">DPS</span></div>';
        const rows = SIM_HISTORY.map(function (h) {
          return '<div class="sim-history-row">' +
            '<span class="sim-history-w1" title="' + (h.weapon1 || '').replace(/"/g, '&quot;') + '">' + (h.weapon1 || '—').replace(/</g, '&lt;') + '</span>' +
            '<span class="sim-history-w2" title="' + (h.weapon2 || '').replace(/"/g, '&quot;') + '">' + (h.weapon2 || '—').replace(/</g, '&lt;') + '</span>' +
            '<span class="sim-history-atk">' + (h.attack != null ? h.attack : '—') + '</span>' +
            '<span class="sim-history-ac">' + (h.mobAC != null ? h.mobAC : '—') + '</span>' +
            '<span class="sim-history-dps">' + (typeof h.dps === 'number' ? h.dps.toFixed(2) : '—') + '</span>' +
            '</div>';
        }).join('');
        listEl.innerHTML = header + rows;
      }

      const clearHistoryBtn = $('sim-history-clear');
      if (clearHistoryBtn) {
        clearHistoryBtn.addEventListener('click', function () {
          SIM_HISTORY.length = 0;
          renderSimHistory();
        });
      }

      function showTab(tabId) {
        const isMelee = tabId === 'melee';
        $('melee-tab').classList.toggle('hidden', !isMelee);
        $('ranged-tab').classList.toggle('hidden', isMelee);
        $('tab-melee').classList.toggle('active', isMelee);
        $('tab-melee').setAttribute('aria-selected', isMelee ? 'true' : 'false');
        $('tab-ranged').classList.toggle('active', !isMelee);
        $('tab-ranged').setAttribute('aria-selected', !isMelee ? 'true' : 'false');
      }
      $('tab-melee').addEventListener('click', function () { showTab('melee'); });
      $('tab-ranged').addEventListener('click', function () { showTab('ranged'); });

      function runRanged() {
        let damage = parseInt($('ranged-damage').value, 10) || 12;
        const delay = parseInt($('ranged-delay').value, 10) || 40;
        if (damage < 1 || delay < 10) {
          $('report').textContent = 'Ranged weapon: set Damage >= 1 and Delay >= 10 (e.g. 40 for 4.0s).';
          return;
        }
        const rangedBane = parseInt($('ranged-bane').value, 10) || 0;
        if ($('ranged-apply-bane').checked && rangedBane) damage += rangedBane;
        const arrowDamage = parseInt($('arrow-damage').value, 10) || 0;
        const runs = Math.max(1, Math.min(1000, parseInt($('ranged-runs').value, 10) || 20));
        const rangedWeapon = {
          damage: damage,
          delay: delay,
          procSpell: ($('ranged-proc').value || '').trim() || undefined,
          procSpellDamage: parseInt($('ranged-proc-damage').value, 10) || 0,
        };
        const rangedElemType = ($('ranged-elem-type').value || '').trim();
        const rangedElemDamage = parseInt($('ranged-elem-damage').value, 10) || 0;
        if (rangedElemType && rangedElemDamage > 0) { rangedWeapon.elemType = rangedElemType; rangedWeapon.elemDamage = rangedElemDamage; }
        const arrow = { damage: arrowDamage };
        const arrowElemType = ($('arrow-elem-type').value || '').trim();
        const arrowElemDamage = parseInt($('arrow-elem-damage').value, 10) || 0;
        if (arrowElemType && arrowElemDamage > 0) { arrow.elemType = arrowElemType; arrow.elemDamage = arrowElemDamage; }
        const options = {
          rangedWeapon,
          arrow,
          hastePercent: parseFloat($('ranged-haste').value, 10) || 0,
          level: parseInt($('ranged-level').value, 10) || 60,
          targetAC: parseInt($('ranged-target-ac').value, 10) || 300,
          mobLevel: parseInt($('ranged-mob-level').value, 10) || 60,
          targetMR: parseInt($('ranged-target-mr').value, 10) || 35,
          targetFR: parseInt($('ranged-target-fr').value, 10) || 35,
          targetCR: parseInt($('ranged-target-cr').value, 10) || 35,
          targetPR: parseInt($('ranged-target-pr').value, 10) || 35,
          targetDR: parseInt($('ranged-target-dr').value, 10) || 35,
          fightDurationSec: parseInt($('ranged-duration').value, 10) || 6000,
          offenseSkill: 252,
          wornAttack: parseInt($('ranged-worn-attack').value, 10) || 0,
          spellAttack: parseInt($('ranged-spell-attack').value, 10) || 0,
          str: 255,
          dex: 255,
          critChanceMult: 0,
          archeryMastery: parseInt(document.querySelector('input[name="archery-mastery"]:checked').value, 10) || 3,
          mobStationary: $('mob-stationary').checked,
          useWalledMobPenalty: $('use-walled-mob-penalty').checked,
        };
        const reports = [];
        for (let i = 0; i < runs; i++) {
          options.seed = runs === 1 ? undefined : (Date.now() + i + 10000);
          const r = EQCombat.runRangedFight(options);
          if (r.error) {
            $('report').textContent = r.error;
            $('histogram-container').innerHTML = '';
            return;
          }
          reports.push(r);
        }
        let report;
        if (runs === 1) {
          report = reports[0];
        } else {
          const r0 = reports[0];
          report = {
            ranged: {
              swings: Math.round(reports.reduce((s, r) => s + r.ranged.swings, 0) / runs),
              hits: Math.round(reports.reduce((s, r) => s + r.ranged.hits, 0) / runs),
              totalDamage: Math.round(reports.reduce((s, r) => s + r.ranged.totalDamage, 0) / runs),
              maxDamage: Math.round(reports.reduce((s, r) => s + r.ranged.maxDamage, 0) / runs),
              minDamage: r0.ranged.minDamage != null ? Math.round(reports.reduce((s, r) => s + (r.ranged.minDamage != null ? r.ranged.minDamage : 0), 0) / runs) : null,
              hitList: reports[0].ranged.hitList,
              procs: Math.round(reports.reduce((s, r) => s + (r.ranged.procs || 0), 0) / runs),
              procDamageTotal: Math.round(reports.reduce((s, r) => s + (r.ranged.procDamageTotal || 0), 0) / runs),
            },
            durationSec: r0.durationSec,
            totalDamage: Math.round(reports.reduce((s, r) => s + r.totalDamage, 0) / runs),
            critHits: Math.round(reports.reduce((s, r) => s + (r.critHits || 0), 0) / runs),
            critDamageGain: Math.round(reports.reduce((s, r) => s + (r.critDamageGain || 0), 0) / runs),
            wallPenaltyDamageLost: r0.wallPenaltyDamageLost != null ? Math.round(reports.reduce((s, r) => s + (r.wallPenaltyDamageLost || 0), 0) / runs) : undefined,
            calculatedToHit: r0.calculatedToHit,
            offenseSkill: r0.offenseSkill,
            offenseRating: r0.offenseRating,
            displayedAttack: r0.displayedAttack,
          };
        }
        $('report').textContent = EQCombat.formatRangedReport(report, runs);
        const dpsEl = $('dps-value');
        if (dpsEl && report.durationSec) dpsEl.textContent = (report.totalDamage / report.durationSec).toFixed(2);
        const histContainer = $('histogram-container');
        if (reports.length > 0 && reports[0].ranged && reports[0].ranged.hitList && reports[0].ranged.hitList.length > 0) {
          renderHistogram(histContainer, { weapon1: reports[0].ranged }, 'Ranged', null);
        } else {
          histContainer.innerHTML = '';
        }

        const rangedWeaponName = (rangedFromItemSearch && rangedWeaponDisplayName) ? rangedWeaponDisplayName : (damage + 'd/' + delay);
        const arrowName = (arrowFromItemSearch && arrowDisplayName) ? arrowDisplayName : (arrowDamage > 0 ? arrowDamage + ' dmg' : '—');
        const rangedTotalAttack = report.displayedAttack != null ? report.displayedAttack : report.offenseRating;
        const rangedDps = report.durationSec > 0 ? (report.totalDamage / report.durationSec) : 0;
        SIM_HISTORY.unshift({
          weapon1: rangedWeaponName,
          weapon2: arrowName,
          attack: rangedTotalAttack,
          mobAC: options.targetAC,
          dps: rangedDps
        });
        if (SIM_HISTORY.length > SIM_HISTORY_MAX) SIM_HISTORY.pop();
        renderSimHistory();

        if (USAGE_LOG_URL) {
          logUsage({
            event: 'sim_run',
            ranged: true,
            v: VERSION,
            uid: getOrCreateAnonymousUserId(),
            ts: Date.now(),
            w1: { name: rangedWeaponName, damage: damage, delay: delay },
            w2: { name: arrowName, damage: arrowDamage },
            classId: 'ranged',
            durationSec: options.fightDurationSec,
            runs,
            totalDamage: report.totalDamage,
          });
        }
      }
      $('btn-run-ranged').addEventListener('click', runRanged);

      function applyAmbidexterityDefault() {
        const classId = ($('class').value || '').toLowerCase();
        const level = parseInt($('level').value, 10) || 60;
        const ambidextrousClasses = ['warrior', 'rogue', 'monk', 'bard', 'beastlord'];
        if (level === 60 && ambidextrousClasses.includes(classId)) {
          $('ambidexterity-aa').checked = true;
        }
      }
      function onClassOrLevelChange() {
        const classId = ($('class').value || '').toLowerCase();
        const c = classId ? CLASSES[classId] : null;
        if (c) {
          $('double-attack').value = c.doubleAttack;
          $('dual-wield').value = c.dualWield;
          $('class-hint').textContent = 'Class and level auto-fill skills and weapon caps. Edit below to override.';
        } else {
          $('class-hint').textContent = 'Pick a class to auto-fill skills. Edit below to override.';
        }
        applyAmbidexterityDefault();
        const hasSpecial = classId === 'monk' || classId === 'rogue';
        $('special-attacks').disabled = !hasSpecial;
        if (!hasSpecial) $('special-attacks').checked = false;
        else if (classId === 'rogue') $('special-attacks').checked = true;
        const rogueRow = $('rogue-backstab-mod-row');
        if (rogueRow) rogueRow.style.display = classId === 'rogue' ? '' : 'none';
        updateFistweavingVisibility();
        updateWeaponSkillInputs();
      }
      $('class').addEventListener('change', onClassOrLevelChange);
      $('level').addEventListener('change', onClassOrLevelChange);
      $('level').addEventListener('input', onClassOrLevelChange);
      function updateFistweavingVisibility() {
        const classId = ($('class').value || '').toLowerCase();
        const is2H = isW1TwoHanded();
        const row = $('fistweaving-row');
        if (row) row.style.display = classId === 'monk' && is2H ? '' : 'none';
      }
      function updateWeapon2Disabled() {
        const is2H = isW1TwoHanded();
        if (is2H) applyWeaponPreset('w2', 'unequipped');
        const section = $('weapon2-section');
        if (section) {
          section.querySelectorAll('select, input').forEach(function (el) { el.disabled = !!is2H; });
          section.classList.toggle('is-disabled', !!is2H);
        }
        updateWeaponNameDisplay('w2');
      }

      var SKILL_TYPE_ALIASES = { '2hp': '1hp', 'bow': 'archery' };
      var VALID_SKILL_KEYS = ['1hb', '1hs', '1hp', '2hb', '2hs', 'h2h', 'archery', 'throwing', 'undefined'];
      function skillKeyForCap(typeOrNull, is2H) {
        const t = (typeOrNull || '').toLowerCase();
        if (t === 'undefined') return 'undefined';
        const key = SKILL_TYPE_ALIASES[t] || t;
        if (VALID_SKILL_KEYS.indexOf(key) >= 0) return key;
        return is2H ? '2hb' : '1hb';
      }
      function getWeaponSkillInput(skillKey) {
        const el = $('skill-' + skillKey);
        return el ? (parseInt(el.value, 10) || 0) : 0;
      }
      function updateWeaponSkillInputs() {
        if (typeof WeaponSkillCaps === 'undefined') return;
        const classId = ($('class').value || '').toLowerCase();
        const level = parseInt($('level').value, 10) || 60;
        if (!classId) return;
        VALID_SKILL_KEYS.forEach(function (key) {
          const cap = WeaponSkillCaps.getCapForSimClass(classId, key, level);
          const el = $('skill-' + key);
          if (el) el.value = cap > 0 ? cap : '';
        });
      }

      $('class').dispatchEvent(new Event('change'));

      applyWeaponPreset('w1', 'unequipped');
      updateWeaponNameDisplay('w1');
      updateWeaponNameDisplay('w2');
      updateWeapon2Disabled();
      function clearItemSearchOnManualEdit(prefix) {
        if (prefix === 'w1') w1FromItemSearch = false; else w2FromItemSearch = false;
      }
      [$('w1-damage'), $('w1-delay')].forEach(function (el) { if (el) el.addEventListener('input', function () { clearItemSearchOnManualEdit('w1'); updateWeaponNameDisplay('w1'); }); });
      [$('w2-damage'), $('w2-delay')].forEach(function (el) { if (el) el.addEventListener('input', function () { clearItemSearchOnManualEdit('w2'); updateWeaponNameDisplay('w2'); }); });
      function onWeaponIconClick(prefix) {
        applyWeaponPreset(prefix, 'unequipped');
        updateWeaponSkillInputs();
        if (prefix === 'w1') { updateFistweavingVisibility(); updateWeapon2Disabled(); }
      }
      const w1Wrap = $('w1-weapon-icon-wrap');
      const w2Wrap = $('w2-weapon-icon-wrap');
      if (w1Wrap) { w1Wrap.title = 'Click to unequip'; w1Wrap.addEventListener('click', function () { onWeaponIconClick('w1'); }); }
      if (w2Wrap) { w2Wrap.title = 'Click to unequip'; w2Wrap.addEventListener('click', function () { onWeaponIconClick('w2'); }); }
      updateWeaponSkillInputs();

      // ----- Item search autofilter (API + recent items) -----
      const ITEM_SEARCH_RECENT_KEY = 'dps_sim_recent_weapons';
      const ITEM_SEARCH_RECENT_RANGED_KEY = 'dps_sim_recent_ranged_weapons';
      const ITEM_SEARCH_RECENT_ARROW_KEY = 'dps_sim_recent_arrows';
      const ITEM_SEARCH_MAX_RECENT = 15;
      const ITEM_SEARCH_MIN_CHARS = 3;
      const ITEM_SEARCH_DEBOUNCE_MS = 300;

      function getRecentWeapons() {
        try {
          const raw = localStorage.getItem(ITEM_SEARCH_RECENT_KEY);
          if (!raw) return [];
          const arr = JSON.parse(raw);
          return Array.isArray(arr) ? arr : [];
        } catch (e) { return []; }
      }

      function weaponKey(w) {
        return (w && w.name) + '|' + (w && w.damage) + '|' + (w && w.delay);
      }

      function saveRecentWeapon(weapon) {
        if (!weapon || !weapon.name) return;
        const key = weaponKey(weapon);
        let recent = getRecentWeapons().filter(function (r) { return weaponKey(r) !== key; });
        recent.unshift(weapon);
        recent = recent.slice(0, ITEM_SEARCH_MAX_RECENT);
        try { localStorage.setItem(ITEM_SEARCH_RECENT_KEY, JSON.stringify(recent)); } catch (e) {}
      }

      function getRecent(prefix) {
        if (prefix === 'w1' || prefix === 'w2') return getRecentWeapons();
        if (prefix === 'ranged-weapon') return getRecentRangedWeapons();
        if (prefix === 'arrow') return getRecentArrows();
        return [];
      }
      function getRecentRangedWeapons() {
        try {
          const raw = localStorage.getItem(ITEM_SEARCH_RECENT_RANGED_KEY);
          if (!raw) return [];
          const arr = JSON.parse(raw);
          return Array.isArray(arr) ? arr : [];
        } catch (e) { return []; }
      }
      function getRecentArrows() {
        try {
          const raw = localStorage.getItem(ITEM_SEARCH_RECENT_ARROW_KEY);
          if (!raw) return [];
          const arr = JSON.parse(raw);
          return Array.isArray(arr) ? arr : [];
        } catch (e) { return []; }
      }
      function saveRecentRangedWeapon(weapon) {
        if (!weapon || !weapon.name) return;
        const key = weaponKey(weapon);
        let recent = getRecentRangedWeapons().filter(function (r) { return weaponKey(r) !== key; });
        recent.unshift(weapon);
        recent = recent.slice(0, ITEM_SEARCH_MAX_RECENT);
        try { localStorage.setItem(ITEM_SEARCH_RECENT_RANGED_KEY, JSON.stringify(recent)); } catch (e) {}
      }
      function saveRecentArrow(weapon) {
        if (!weapon || !weapon.name) return;
        const key = (weapon && weapon.name) + '|' + (weapon && weapon.damage) + '|' + (weapon && weapon.elemType);
        let recent = getRecentArrows().filter(function (r) { return ((r && r.name) + '|' + (r && r.damage) + '|' + (r && r.elemType)) !== key; });
        recent.unshift(weapon);
        recent = recent.slice(0, ITEM_SEARCH_MAX_RECENT);
        try { localStorage.setItem(ITEM_SEARCH_RECENT_ARROW_KEY, JSON.stringify(recent)); } catch (e) {}
      }

      function updateItemSearchDebug(slotLabel, weapon) {
        const el = $('item-search-debug-content');
        if (!el) return;
        if (!weapon) {
          el.textContent = 'Select an item from search to see API itemType and mapped type.';
          return;
        }
        const apiType = weapon.itemTypeNum != null ? weapon.itemTypeNum : '(not set)';
        const mapped = (weapon.type != null && weapon.type !== '') ? weapon.type : '(undefined)';
        const slots = weapon.slots != null ? weapon.slots : '(not set)';
        el.textContent = 'Slot: ' + slotLabel + '\nName: ' + (weapon.name || '—') + '\nAPI itemType: ' + apiType + '\nMapped type: ' + mapped + '\nSlots bitmask: ' + slots;
      }

      /** Populate weapon form fields from selected item (JSON/normalized weapon: damage, delay, proc, procDamage, elemType, elemDamage, baneDamage). */
      function applyWeaponFromSearch(prefix, weapon) {
        if (!weapon) return;
        updateItemSearchDebug(prefix === 'w1' ? 'W1' : 'W2', weapon);
        const offhandBlockedTypes = { '2hs': 1, '2hp': 1, '2hb': 1, 'archery': 1, 'bow': 1 };
        if (prefix === 'w2' && (weapon.is2H || weapon.offhandBlocked || (weapon.type && offhandBlockedTypes[weapon.type]))) return;
        const dmg = Number(weapon.damage);
        const dly = Number(weapon.delay);
        const procDmg = Number(weapon.procDamage);
        const elemDmg = Number(weapon.elemDamage);
        const bane = Number(weapon.baneDamage);
        $(prefix + '-damage').value = isNaN(dmg) ? '' : dmg;
        $(prefix + '-delay').value = isNaN(dly) ? '' : dly;
        $(prefix + '-proc').value = (weapon.proc != null ? String(weapon.proc) : '') || '';
        const procDmgEl = $(prefix + '-proc-damage');
        if (procDmgEl) procDmgEl.value = isNaN(procDmg) ? '' : procDmg;
        const elemTypeEl = $(prefix + '-elem-type');
        if (elemTypeEl) elemTypeEl.value = (weapon.elemType != null ? String(weapon.elemType) : '') || '';
        const elemDamageEl = $(prefix + '-elem-damage');
        if (elemDamageEl) elemDamageEl.value = isNaN(elemDmg) ? '' : elemDmg;
        const baneEl = $(prefix + '-bane');
        if (baneEl) baneEl.value = isNaN(bane) ? '' : bane;
        const backstabModEl = $('backstab-mod');
        if (prefix === 'w1' && backstabModEl && weapon.backstabModPercent != null && !isNaN(Number(weapon.backstabModPercent))) {
          backstabModEl.value = Number(weapon.backstabModPercent);
        }
        updateWeaponIcon(prefix, weapon.icon);
        var normType = (weapon.type != null && weapon.type !== '') ? String(weapon.type).trim().toLowerCase() : null;
        if (prefix === 'w1') { w1DisplayName = (weapon.name || '').trim() || 'Custom'; w1FromItemSearch = true; w1WeaponType = normType; } else { w2DisplayName = (weapon.name || '').trim() || 'Custom'; w2FromItemSearch = true; w2WeaponType = normType; }
        updateWeaponNameDisplay(prefix);
        updateWeaponSkillInputs();
        if (prefix === 'w1') {
          const type2H = normType === '2hb' || normType === '2hs' || normType === '2hp' || normType === 'bow';
          const is2H = !!weapon.is2H || !!type2H;
          const overrideEl = $('w1-is2h-override');
          if (overrideEl) overrideEl.value = is2H ? '1' : '0';
          if (is2H) applyWeaponPreset('w2', 'unequipped');
          updateWeapon2Disabled();
          updateFistweavingVisibility();
        }
      }

      function applyRangedWeaponFromSearch(weapon) {
        if (!weapon) return;
        updateItemSearchDebug('Ranged weapon', weapon);
        const dmg = Number(weapon.damage);
        const dly = Number(weapon.delay);
        $('ranged-damage').value = isNaN(dmg) ? '' : dmg;
        $('ranged-delay').value = isNaN(dly) ? '' : dly;
        $('ranged-proc').value = (weapon.proc != null ? String(weapon.proc) : '') || '';
        $('ranged-proc-damage').value = (weapon.procDamage != null && !isNaN(Number(weapon.procDamage)) ? Number(weapon.procDamage) : 0) || '';
        $('ranged-elem-type').value = (weapon.elemType != null ? String(weapon.elemType) : '') || '';
        $('ranged-elem-damage').value = (weapon.elemDamage != null && !isNaN(Number(weapon.elemDamage)) ? Number(weapon.elemDamage) : 0) || '';
        $('ranged-bane').value = (weapon.baneDamage != null && !isNaN(Number(weapon.baneDamage)) ? Number(weapon.baneDamage) : 0) || '';
        rangedWeaponDisplayName = (weapon.name || '').trim() || 'Custom';
        rangedFromItemSearch = true;
      }

      function applyArrowFromSearch(weapon) {
        if (!weapon) return;
        updateItemSearchDebug('Arrow', weapon);
        const dmg = Number(weapon.damage);
        $('arrow-damage').value = isNaN(dmg) ? '' : dmg;
        $('arrow-elem-type').value = (weapon.elemType != null ? String(weapon.elemType) : '') || '';
        $('arrow-elem-damage').value = (weapon.elemDamage != null && !isNaN(Number(weapon.elemDamage)) ? Number(weapon.elemDamage) : 0) || '';
        arrowDisplayName = (weapon.name || '').trim() || 'Custom';
        arrowFromItemSearch = true;
      }

      function debounce(fn, ms) {
        let t = null;
        return function () {
          const args = arguments;
          if (t) clearTimeout(t);
          t = setTimeout(function () { fn.apply(null, args); }, ms);
        };
      }

      function renderItemLabel(w) {
        let detail = (w.damage != null ? w.damage : 0) + ' / ' + (w.delay != null ? w.delay : 0);
        if (w.proc) detail += ' — ' + w.proc;
        if (w.elemType && (w.elemDamage || 0) > 0) detail += ' +' + (w.elemDamage || 0) + ' ' + w.elemType;
        if ((w.baneDamage || 0) > 0) detail += ' bane ' + w.baneDamage;
        return detail;
      }

      function slotOkForPrefix(prefix, w) {
        if (!w || typeof ItemSearch === 'undefined' || !ItemSearch.itemMatchesSlot) return true;
        if (prefix === 'w1') return ItemSearch.itemMatchesSlot(w, ItemSearch.SLOT_PRIMARY);
        if (prefix === 'w2') return ItemSearch.itemMatchesSlot(w, ItemSearch.SLOT_SECONDARY);
        if (prefix === 'ranged-weapon') return ItemSearch.itemMatchesSlot(w, ItemSearch.SLOT_RANGED);
        if (prefix === 'arrow') return ItemSearch.itemMatchesSlot(w, ItemSearch.SLOT_AMMO);
        return true;
      }

      function renderDropdown(prefix, recent, results, loading, query) {
        const listEl = $(prefix + '-item-search-list');
        if (!listEl) return;
        recent = recent || getRecent(prefix);
        recent = recent.filter(function (w) { return slotOkForPrefix(prefix, w); });
        results = results ? results.filter(function (w) { return slotOkForPrefix(prefix, w); }) : [];
        const omit2H = prefix === 'w2';
        if (omit2H) {
          const offhandBlockedTypes = { '2hs': 1, '2hp': 1, '2hb': 1, 'archery': 1, 'bow': 1 };
          const offhandOk = function (w) {
            if (w.is2H || w.offhandBlocked) return false;
            if (w.type && offhandBlockedTypes[w.type]) return false;
            return true;
          };
          recent = recent.filter(offhandOk);
          results = results.filter(offhandOk);
        }
        const q = (query || '').trim();
        const hasQuery = q.length >= ITEM_SEARCH_MIN_CHARS;
        let html = '';
        function renderRecent() {
          if (!recent || recent.length === 0) return '';
          let s = '<div class="item-search-section">Recent</div>';
          recent.forEach(function (w) {
            const label = renderItemLabel(w);
            s += '<button type="button" class="item-search-item" data-name="' + (w.name || '').replace(/"/g, '&quot;') + '" data-damage="' + (w.damage != null ? w.damage : '') + '" data-delay="' + (w.delay != null ? w.delay : '') + '" data-weapon-type="' + (w.type || '').replace(/"/g, '&quot;') + '" data-item-type-num="' + (w.itemTypeNum != null ? String(w.itemTypeNum) : '') + '" data-slots="' + (w.slots != null ? String(w.slots) : '') + '" data-proc="' + (w.proc || '').replace(/"/g, '&quot;') + '" data-procdamage="' + (w.procDamage != null ? w.procDamage : '') + '" data-elemtype="' + (w.elemType || '').replace(/"/g, '&quot;') + '" data-elemdamage="' + (w.elemDamage != null ? w.elemDamage : '') + '" data-bane="' + (w.baneDamage != null ? w.baneDamage : '') + '" data-backstab-mod="' + (w.backstabModPercent != null ? String(w.backstabModPercent) : '') + '" data-icon="' + (w.icon != null && w.icon > 0 ? w.icon : '') + '" data-is2h="' + (w.is2H ? '1' : '0') + '" data-offhand-blocked="' + (w.offhandBlocked ? '1' : '0') + '"><span>' + (w.name || '').replace(/</g, '&lt;') + '</span><div class="item-search-item-detail">' + label.replace(/</g, '&lt;') + '</div></button>';
          });
          return s;
        }
        function renderSearch() {
          if (loading) return '<div class="item-search-section">Search results</div><div class="item-search-msg">Searching...</div>';
          if (!hasQuery) return '';
          let s = '<div class="item-search-section">Search results</div>';
          if (!results || results.length === 0) {
            s += '<div class="item-search-msg">No results</div>';
          } else {
            results.forEach(function (w) {
              const label = renderItemLabel(w);
              s += '<button type="button" class="item-search-item item-search-item-result" data-name="' + (w.name || '').replace(/"/g, '&quot;') + '" data-damage="' + (w.damage != null ? w.damage : '') + '" data-delay="' + (w.delay != null ? w.delay : '') + '" data-weapon-type="' + (w.type || '').replace(/"/g, '&quot;') + '" data-item-type-num="' + (w.itemTypeNum != null ? String(w.itemTypeNum) : '') + '" data-slots="' + (w.slots != null ? String(w.slots) : '') + '" data-proc="' + (w.proc || '').replace(/"/g, '&quot;') + '" data-procdamage="' + (w.procDamage != null ? w.procDamage : '') + '" data-elemtype="' + (w.elemType || '').replace(/"/g, '&quot;') + '" data-elemdamage="' + (w.elemDamage != null ? w.elemDamage : '') + '" data-bane="' + (w.baneDamage != null ? w.baneDamage : '') + '" data-backstab-mod="' + (w.backstabModPercent != null ? String(w.backstabModPercent) : '') + '" data-icon="' + (w.icon != null && w.icon > 0 ? w.icon : '') + '" data-is2h="' + (w.is2H ? '1' : '0') + '" data-offhand-blocked="' + (w.offhandBlocked ? '1' : '0') + '"><span>' + (w.name || '').replace(/</g, '&lt;') + '</span><div class="item-search-item-detail">' + label.replace(/</g, '&lt;') + '</div></button>';
            });
          }
          return s;
        }
        html += hasQuery ? (renderSearch() + renderRecent()) : (renderRecent() + renderSearch());
        if (!html && !hasQuery) {
          html = '<div class="item-search-msg">Type at least ' + ITEM_SEARCH_MIN_CHARS + ' characters to search</div>';
        }
        listEl.innerHTML = html;
        listEl.querySelectorAll('.item-search-item').forEach(function (btn) {
          btn.addEventListener('mousedown', function (e) {
            e.preventDefault();
            const num = function (v) { const n = parseInt(v, 10); return isNaN(n) ? 0 : n; };
            const numOrNull = function (v) { if (v === null || v === undefined || v === '') return null; const n = parseInt(v, 10); return isNaN(n) ? null : n; };
            const iconVal = num(btn.getAttribute('data-icon'));
            const weaponTypeRaw = (btn.getAttribute('data-weapon-type') || '').trim();
            const typeLower = weaponTypeRaw ? weaponTypeRaw.toLowerCase() : '';
            const derived2H = typeLower === '2hb' || typeLower === '2hs' || typeLower === '2hp' || typeLower === 'bow';
            const w = {
              name: (btn.getAttribute('data-name') || '').trim(),
              damage: num(btn.getAttribute('data-damage')),
              delay: num(btn.getAttribute('data-delay')),
              type: typeLower || weaponTypeRaw || null,
              itemTypeNum: numOrNull(btn.getAttribute('data-item-type-num')),
              slots: numOrNull(btn.getAttribute('data-slots')),
              proc: (btn.getAttribute('data-proc') || '').trim(),
              procDamage: num(btn.getAttribute('data-procdamage')),
              elemType: (btn.getAttribute('data-elemtype') || '').trim(),
              elemDamage: num(btn.getAttribute('data-elemdamage')),
              baneDamage: num(btn.getAttribute('data-bane')),
              backstabModPercent: numOrNull(btn.getAttribute('data-backstab-mod')),
              icon: iconVal > 0 ? iconVal : null,
              is2H: btn.getAttribute('data-is2h') === '1' || derived2H,
              offhandBlocked: btn.getAttribute('data-offhand-blocked') === '1' || derived2H
            };
            const inputEl = $(prefix + '-item-search');
            if (prefix === 'ranged-weapon') {
              saveRecentRangedWeapon(w);
              applyRangedWeaponFromSearch(w);
            } else if (prefix === 'arrow') {
              saveRecentArrow(w);
              applyArrowFromSearch(w);
            } else {
              saveRecentWeapon(w);
              applyWeaponFromSearch(prefix, w);
            }
            if (inputEl) inputEl.value = '';
            closeItemSearchDropdown(prefix);
          });
        });
      }

      function openItemSearchDropdown(prefix) {
        const listEl = $(prefix + '-item-search-list');
        if (listEl) listEl.classList.add('is-open');
      }
      function closeItemSearchDropdown(prefix) {
        const listEl = $(prefix + '-item-search-list');
        if (listEl) listEl.classList.remove('is-open');
      }

      function runItemSearch(prefix) {
        const inputEl = $(prefix + '-item-search');
        const query = (inputEl && inputEl.value || '').trim();
        const recent = getRecent(prefix);
        if (query.length < ITEM_SEARCH_MIN_CHARS) {
          renderDropdown(prefix, recent, null, false, query);
          openItemSearchDropdown(prefix);
          return;
        }
        renderDropdown(prefix, recent, null, true, query);
        openItemSearchDropdown(prefix);
        if (typeof ItemSearch === 'undefined' || !ItemSearch.searchWeapons) {
          renderDropdown(prefix, recent, [], false, query);
          return;
        }
        ItemSearch.searchWeapons(query).then(function (results) {
          const recentNow = getRecent(prefix);
          renderDropdown(prefix, recentNow, results || [], false, query);
        }).catch(function () {
          renderDropdown(prefix, getRecent(prefix), [], false, query);
        });
      }

      function setupItemSearch(prefix) {
        const inputEl = $(prefix + '-item-search');
        const listEl = $(prefix + '-item-search-list');
        if (!inputEl || !listEl) return;
        const debouncedSearch = debounce(function () { runItemSearch(prefix); }, ITEM_SEARCH_DEBOUNCE_MS);
        inputEl.addEventListener('focus', function () {
          runItemSearch(prefix);
        });
        inputEl.addEventListener('input', function () {
          debouncedSearch();
        });
        inputEl.addEventListener('keydown', function (e) {
          if (e.key === 'Escape') { closeItemSearchDropdown(prefix); inputEl.blur(); }
        });
      }

      document.addEventListener('click', function (e) {
        if (e.target.closest('.item-search-wrap')) return;
        closeItemSearchDropdown('w1');
        closeItemSearchDropdown('w2');
        closeItemSearchDropdown('ranged-weapon');
        closeItemSearchDropdown('arrow');
      });

      setupItemSearch('w1');
      setupItemSearch('w2');
      setupItemSearch('ranged-weapon');
      setupItemSearch('arrow');

      function clearRangedArrowItemSearchOnManualEdit(kind) {
        if (kind === 'ranged') { rangedFromItemSearch = false; }
        if (kind === 'arrow') { arrowFromItemSearch = false; }
      }
      [$('ranged-damage'), $('ranged-delay'), $('ranged-proc'), $('ranged-proc-damage'), $('ranged-elem-type'), $('ranged-elem-damage'), $('ranged-bane')].forEach(function (el) {
        if (el) el.addEventListener('input', function () { clearRangedArrowItemSearchOnManualEdit('ranged'); });
      });
      [$('arrow-damage'), $('arrow-elem-type'), $('arrow-elem-damage')].forEach(function (el) {
        if (el) el.addEventListener('input', function () { clearRangedArrowItemSearchOnManualEdit('arrow'); });
      });
    })();
  </script>
</body>
</html>
